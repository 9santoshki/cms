{"version":3,"sources":["turbopack:///[next]/internal/font/google/inter_5972bc34.module.css [app-rsc] (css module)","turbopack:///[next]/internal/font/google/playfair_display_a6b1faec.module.css [app-rsc] (css module)","turbopack:///[next]/internal/font/google/montserrat_14730532.module.css [app-rsc] (css module)","turbopack:///[project]/src/context/AuthContext.tsx/__nextjs-internal-proxy.mjs","turbopack:///[project]/src/context/AuthContext.tsx","turbopack:///[project]/src/context/CartContext.tsx/__nextjs-internal-proxy.mjs","turbopack:///[project]/src/context/CartContext.tsx","turbopack:///[project]/src/context/ProductContext.tsx/__nextjs-internal-proxy.mjs","turbopack:///[project]/src/context/ProductContext.tsx","turbopack:///[project]/src/context/UIContext.tsx/__nextjs-internal-proxy.mjs","turbopack:///[project]/src/context/UIContext.tsx","turbopack:///[project]/src/context/AppProvider.tsx/__nextjs-internal-proxy.mjs","turbopack:///[project]/src/context/AppProvider.tsx","turbopack:///[next]/internal/font/google/playfair_display_a6b1faec.js","turbopack:///[next]/internal/font/google/montserrat_14730532.js","turbopack:///[project]/src/context/AppContext.tsx","turbopack:///[next]/internal/font/google/inter_5972bc34.js","turbopack:///[project]/src/app/layout.tsx","turbopack:///[project]/src/context/CombinedAppContext.ts"],"sourcesContent":["__turbopack_context__.v({\n  \"className\": \"inter_5972bc34-module__OU16Qa__className\",\n});\n","__turbopack_context__.v({\n  \"className\": \"playfair_display_a6b1faec-module__v-9lQG__className\",\n  \"variable\": \"playfair_display_a6b1faec-module__v-9lQG__variable\",\n});\n","__turbopack_context__.v({\n  \"className\": \"montserrat_14730532-module__3Wk8jq__className\",\n  \"variable\": \"montserrat_14730532-module__3Wk8jq__variable\",\n});\n","// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport const AuthContext = registerClientReference(\n    function() { throw new Error(\"Attempted to call AuthContext() from the server but AuthContext is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/context/AuthContext.tsx\",\n    \"AuthContext\",\n);\nexport const AuthProvider = registerClientReference(\n    function() { throw new Error(\"Attempted to call AuthProvider() from the server but AuthProvider is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/context/AuthContext.tsx\",\n    \"AuthProvider\",\n);\nexport const useAuth = registerClientReference(\n    function() { throw new Error(\"Attempted to call useAuth() from the server but useAuth is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/context/AuthContext.tsx\",\n    \"useAuth\",\n);\n","'use client';\n\nimport React, { createContext, useContext, useReducer, useCallback, useEffect } from 'react';\nimport { User } from '@/types';\nimport { signInWithGoogle as googleSignIn, signOut, onAuthStateChange, getCurrentUser, getUserProfile } from '@/lib/auth/client';\n\ninterface AuthState {\n  user: User | null;\n  token: string | null;\n  loading: boolean;\n  error: string | null;\n}\n\ntype AuthAction =\n  | { type: 'SET_USER'; payload: User | null }\n  | { type: 'SET_TOKEN'; payload: string | null }\n  | { type: 'SET_LOADING'; payload: boolean }\n  | { type: 'SET_ERROR'; payload: string | null }\n  | { type: 'LOGOUT' };\n\nconst initialState: AuthState = {\n  user: null,\n  token: null,\n  loading: false,\n  error: null,\n};\n\nfunction authReducer(state: AuthState, action: AuthAction): AuthState {\n  switch (action.type) {\n    case 'SET_USER': return { ...state, user: action.payload };\n    case 'SET_TOKEN': return { ...state, token: action.payload };\n    case 'SET_LOADING': return { ...state, loading: action.payload };\n    case 'SET_ERROR': return { ...state, error: action.payload };\n    case 'LOGOUT': return { ...state, user: null, token: null };\n    default: return state;\n  }\n}\n\nexport const AuthContext = createContext<any>(undefined);\n\nexport const AuthProvider = ({ children }: { children: React.ReactNode }) => {\n  const [state, dispatch] = useReducer(authReducer, initialState);\n\n  // Memoized setters\n  const setUser = useCallback((u: User | null) => dispatch({ type: 'SET_USER', payload: u }), []);\n  const setToken = useCallback((t: string | null) => dispatch({ type: 'SET_TOKEN', payload: t }), []);\n  const setLoading = useCallback((l: boolean) => dispatch({ type: 'SET_LOADING', payload: l }), []);\n  const setError = useCallback((e: string | null) => dispatch({ type: 'SET_ERROR', payload: e }), []);\n\n  // Clean Logout\n  const logout = useCallback(async () => {\n    dispatch({ type: 'LOGOUT' });\n    try { await signOut(); } catch (e) {}\n  }, []);\n\n  // Google Login\n  const signInWithGoogle = useCallback(async () => {\n    setLoading(true);\n    setError(null);\n\n    try {\n      await googleSignIn();\n    } catch (err: any) {\n      setError(err?.message || 'Google sign-in failed');\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  }, [setLoading, setError]);\n\n  // ðŸ”¥ Stable auth listener with initial session check\n  useEffect(() => {\n    console.log('AuthContext: Setting up auth state change listener');\n\n    // Check current session on mount - run immediately without delay\n    const checkCurrentSession = async () => {\n      console.log('AuthContext: Checking current session on mount...');\n\n      try {\n        const user = await getCurrentUser();\n        console.log('AuthContext: getCurrentUser result:', user);\n        if (user) {\n          console.log('AuthContext: Current user found on mount:', user);\n          setUser(user);\n\n          // Load user's cart from server IMMEDIATELY\n          try {\n            const { useCartStore } = await import('@/store/cartStore');\n            console.log('AuthContext: Loading cart from server...');\n            await useCartStore.getState().loadServerCart();\n            console.log('AuthContext: âœ… Cart loaded from server successfully');\n          } catch (cartError) {\n            console.error('AuthContext: âŒ Error loading cart:', cartError);\n          }\n        } else {\n          console.log('AuthContext: No current user found on mount');\n        }\n      } catch (error) {\n        console.error('AuthContext: Error checking current session:', error);\n      }\n    };\n\n    // Run immediately - don't delay with setTimeout\n    checkCurrentSession();\n\n    console.log('AuthContext: Subscribing to auth state changes...');\n    const sub = onAuthStateChange(async (event, session) => {\n      console.log('AuthContext: Auth state changed event:', event, 'Session:', session);\n\n      if (event === 'SIGNED_IN') {\n        const user = session.user;\n        if (!user) return;\n\n        console.log('AuthContext: Processing SIGNED_IN event for user:', user);\n        setUser(user);\n        setToken(null); // We use cookie-based sessions now\n\n        // Load user's cart from server after sign in\n        try {\n          const { useCartStore } = await import('@/store/cartStore');\n          console.log('AuthContext: Loading cart after sign in...');\n          await useCartStore.getState().loadServerCart();\n          console.log('AuthContext: âœ… Cart loaded from server after sign in');\n        } catch (cartError) {\n          console.error('AuthContext: âŒ Error loading cart after sign in:', cartError);\n        }\n      }\n\n      if (event === 'SIGNED_OUT') {\n        console.log('AuthContext: Processing SIGNED_OUT event');\n        dispatch({ type: 'LOGOUT' });\n\n        // Clear local cart state only (keep database cart for when user logs back in)\n        try {\n          const { useCartStore } = await import('@/store/cartStore');\n          useCartStore.setState({ items: [] });\n          console.log('AuthContext: âœ… Local cart state cleared after sign out (database cart preserved)');\n        } catch (cartError) {\n          console.error('AuthContext: âŒ Error clearing cart after sign out:', cartError);\n        }\n      }\n\n      if (event === 'USER_UPDATED') {\n        console.log('AuthContext: Processing USER_UPDATED event');\n        const user = session.user;\n        if (!user) return;\n\n        setUser(user);\n      }\n    });\n\n    // Reload cart when window regains focus (in case user logged in from another tab)\n    const handleWindowFocus = async () => {\n      console.log('AuthContext: Window focused, checking for cart updates...');\n      try {\n        const user = await getCurrentUser();\n        if (user) {\n          const { useCartStore } = await import('@/store/cartStore');\n          await useCartStore.getState().loadServerCart();\n          console.log('AuthContext: âœ… Cart reloaded on window focus');\n        }\n      } catch (error) {\n        console.error('AuthContext: âŒ Error reloading cart on focus:', error);\n      }\n    };\n\n    window.addEventListener('focus', handleWindowFocus);\n\n    return () => {\n      console.log('AuthContext: Cleaning up auth subscription');\n      window.removeEventListener('focus', handleWindowFocus);\n      sub.unsubscribe();\n    };\n  }, [setUser, setToken]);\n\n  return (\n    <AuthContext.Provider\n      value={{\n        ...state,\n        setUser,\n        setToken,\n        setLoading,\n        setError,\n        signInWithGoogle,\n        logout,\n      }}\n    >\n      {children}\n    </AuthContext.Provider>\n  );\n};\n\nexport const useAuth = () => {\n  const ctx = useContext(AuthContext);\n  if (!ctx) throw new Error('useAuth must be used within AuthProvider');\n  return ctx;\n};\n","// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport const CartContext = registerClientReference(\n    function() { throw new Error(\"Attempted to call CartContext() from the server but CartContext is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/context/CartContext.tsx\",\n    \"CartContext\",\n);\nexport const CartProvider = registerClientReference(\n    function() { throw new Error(\"Attempted to call CartProvider() from the server but CartProvider is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/context/CartContext.tsx\",\n    \"CartProvider\",\n);\nexport const useCart = registerClientReference(\n    function() { throw new Error(\"Attempted to call useCart() from the server but useCart is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/context/CartContext.tsx\",\n    \"useCart\",\n);\n","'use client';\n\nimport React, { createContext, useContext } from 'react';\nimport { useCartStore } from '@/store/cartStore'; // Assuming you have this Zustand store\n\n// Create context\nexport const CartContext = createContext<{\n  items: any[];\n  loading: boolean;\n  error: string | null;\n  cartCount: number;\n  cartTotal: number;\n  addItem: (item: any) => void;\n  updateItem: (productId: number, quantity: number) => void;\n  removeItem: (productId: number) => void;\n  clearCart: () => void;\n} | undefined>(undefined);\n\n// Define cart item type\ninterface CartItem {\n  id: number;\n  product_id: number;\n  quantity: number;\n  name?: string;\n  price?: number;\n  image_url?: string;\n}\n\n// Provider component\ninterface CartProviderProps {\n  children: React.ReactNode;\n}\n\nexport const CartProvider: React.FC<CartProviderProps> = ({ children }) => {\n  const { items, addItem, updateItem, removeItem, clearCart, getTotalItems, getTotalPrice } = useCartStore();\n  \n  return (\n    <CartContext.Provider\n      value={{\n        items,\n        loading: false,\n        error: null,\n        cartCount: getTotalItems(),\n        cartTotal: getTotalPrice(),\n        addItem,\n        updateItem,\n        removeItem,\n        clearCart\n      }}\n    >\n      {children}\n    </CartContext.Provider>\n  );\n};\n\nexport const useCart = () => {\n  const context = useContext(CartContext);\n  if (context === undefined) {\n    throw new Error('useCart must be used within a CartProvider');\n  }\n  return context;\n};","// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport const ProductContext = registerClientReference(\n    function() { throw new Error(\"Attempted to call ProductContext() from the server but ProductContext is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/context/ProductContext.tsx\",\n    \"ProductContext\",\n);\nexport const ProductProvider = registerClientReference(\n    function() { throw new Error(\"Attempted to call ProductProvider() from the server but ProductProvider is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/context/ProductContext.tsx\",\n    \"ProductProvider\",\n);\nexport const useProduct = registerClientReference(\n    function() { throw new Error(\"Attempted to call useProduct() from the server but useProduct is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/context/ProductContext.tsx\",\n    \"useProduct\",\n);\n","'use client';\n\nimport React, { createContext, useContext, useReducer, useCallback } from 'react';\nimport { apiClient } from '@/lib/api';\n\ninterface ProductState {\n  products: any[];\n  loading: boolean;\n  error: string | null;\n  appointments: any[];\n  orders: any[];\n}\n\ninterface ProductAction {\n  type: string;\n  payload?: any;\n}\n\n// Action types\nconst PRODUCT_ACTIONS = {\n  SET_PRODUCTS: 'SET_PRODUCTS',\n  SET_LOADING: 'SET_LOADING',\n  SET_ERROR: 'SET_ERROR',\n  SET_APPOINTMENTS: 'SET_APPOINTMENTS',\n  SET_ORDERS: 'SET_ORDERS',\n  ADD_ORDER: 'ADD_ORDER'\n};\n\n// Initial state\nconst initialState: ProductState = {\n  products: [],\n  loading: false,\n  error: null,\n  appointments: [],\n  orders: []\n};\n\n// Reducer\nconst productReducer = (state: ProductState, action: ProductAction): ProductState => {\n  switch (action.type) {\n    case PRODUCT_ACTIONS.SET_PRODUCTS:\n      return {\n        ...state,\n        products: Array.isArray(action.payload) ? action.payload : []\n      };\n    case PRODUCT_ACTIONS.SET_LOADING:\n      return {\n        ...state,\n        loading: action.payload\n      };\n    case PRODUCT_ACTIONS.SET_ERROR:\n      return {\n        ...state,\n        error: action.payload\n      };\n    case PRODUCT_ACTIONS.SET_APPOINTMENTS:\n      return {\n        ...state,\n        appointments: Array.isArray(action.payload) ? action.payload : []\n      };\n    case PRODUCT_ACTIONS.SET_ORDERS:\n      return {\n        ...state,\n        orders: Array.isArray(action.payload) ? action.payload : []\n      };\n    case PRODUCT_ACTIONS.ADD_ORDER:\n      return {\n        ...state,\n        orders: [action.payload, ...state.orders]\n      };\n    default:\n      return state;\n  }\n};\n\n// Create context\nexport const ProductContext = createContext<{\n  products: any[];\n  loading: boolean;\n  error: string | null;\n  appointments: any[];\n  orders: any[];\n  setProducts: (products: any[]) => void;\n  setLoading: (loading: boolean) => void;\n  setError: (error: string | null) => void;\n  setAppointments: (appointments: any[]) => void;\n  setOrders: (orders: any[]) => void;\n  fetchProducts: () => Promise<void>;\n  fetchOrders: () => Promise<void>;\n  fetchAppointments: () => Promise<void>;\n  createOrder: (orderData: any) => Promise<any>;\n  createAppointment: (appointmentData: any) => Promise<any>;\n  updateProduct: (id: number, data: any) => Promise<any>;\n  deleteProduct: (id: number) => Promise<any>;\n  createProduct: (productData: any) => Promise<any>;\n} | undefined>(undefined);\n\n// Provider component\ninterface ProductProviderProps {\n  children: React.ReactNode;\n}\n\nexport const ProductProvider: React.FC<ProductProviderProps> = ({ children }) => {\n  const [state, dispatch] = useReducer(productReducer, initialState);\n\n  // Actions\n  const setProducts = (products: any[]) => {\n    dispatch({ type: PRODUCT_ACTIONS.SET_PRODUCTS, payload: products });\n  };\n\n  const setLoading = (loading: boolean) => {\n    dispatch({ type: PRODUCT_ACTIONS.SET_LOADING, payload: loading });\n  };\n\n  const setError = (error: string | null) => {\n    dispatch({ type: PRODUCT_ACTIONS.SET_ERROR, payload: error });\n  };\n\n  const setAppointments = (appointments: any[]) => {\n    dispatch({ type: PRODUCT_ACTIONS.SET_APPOINTMENTS, payload: appointments });\n  };\n\n  const setOrders = (orders: any[]) => {\n    dispatch({ type: PRODUCT_ACTIONS.SET_ORDERS, payload: orders });\n  };\n\n  // Fetch products\n  const fetchProducts = async () => {\n    setLoading(true);\n    setError(null);\n\n    try {\n      const response = await apiClient.getProducts();\n      if (response.success && response.data) {\n        // Handle the new response structure with pagination\n        const productsData = Array.isArray(response.data) ? response.data : (response.data as any)?.products || [];\n\n        // Convert price strings to numbers for proper formatting\n        // Map mock image_url identifiers to appropriate imageClass values\n        const mapImageIdentifierToClass = (identifier: string) => {\n          if (!identifier) return 'modern';\n\n          const lowerIdentifier = identifier.toLowerCase();\n          if (lowerIdentifier.includes('modern') || lowerIdentifier.includes('coffee') || lowerIdentifier.includes('sofa')) {\n            return 'modern';\n          } else if (lowerIdentifier.includes('classic') || lowerIdentifier.includes('armchair')) {\n            return 'classic';\n          } else if (lowerIdentifier.includes('vintage') || lowerIdentifier.includes('lamp')) {\n            return 'coastal'; // Using coastal for lighting items\n          } else if (lowerIdentifier.includes('dining') || lowerIdentifier.includes('dresser')) {\n            return 'office'; // Using office for furniture items\n          } else if (lowerIdentifier.includes('wall') || lowerIdentifier.includes('art')) {\n            return 'hotel'; // Using hotel for decor items\n          } else if (lowerIdentifier.includes('rug')) {\n            return 'restaurant'; // Using restaurant for decor items\n          } else {\n            return 'modern'; // default\n          }\n        };\n\n        const formattedProducts = productsData.map((product: any) => ({\n          ...product,\n          price: typeof product.price === 'number' ? product.price : parseFloat(product.price),\n          // Only set image_url to undefined if it's not a proper URL\n          // If it looks like an actual URL (contains http), keep it\n          image_url: product.image_url && (product.image_url.startsWith('http') || product.image_url.startsWith('/'))\n            ? product.image_url\n            : undefined,\n          // Use the identifier to determine the appropriate CSS class\n          imageClass: mapImageIdentifierToClass(product.image_url) || product.imageClass || 'modern'\n        }));\n        setProducts(formattedProducts);\n      } else {\n        console.warn('No products found:', response.error);\n        // Even if no products are found, we should still set the products state\n        // and turn off loading to avoid the infinite loading state\n        setProducts([]);\n      }\n    } catch (error: any) {\n      console.error('Error fetching products:', error);\n      setError(error.message || 'Failed to load products. Please try again later.');\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // Fetch orders\n  const fetchOrders = useCallback(async () => {\n    dispatch({ type: PRODUCT_ACTIONS.SET_LOADING, payload: true });\n    dispatch({ type: PRODUCT_ACTIONS.SET_ERROR, payload: null });\n    try {\n      const response = await apiClient.getOrders();\n      if (response.success && response.data) {\n        dispatch({ type: PRODUCT_ACTIONS.SET_ORDERS, payload: Array.isArray(response.data) ? response.data : [] });\n      } else {\n        dispatch({ type: PRODUCT_ACTIONS.SET_ORDERS, payload: [] });\n      }\n    } catch (error: any) {\n      console.error('Error fetching orders:', error);\n      dispatch({ type: PRODUCT_ACTIONS.SET_ERROR, payload: error.message || 'Failed to load orders.' });\n    } finally {\n      dispatch({ type: PRODUCT_ACTIONS.SET_LOADING, payload: false });\n    }\n  }, []);\n\n  // Fetch appointments\n  const fetchAppointments = useCallback(async () => {\n    dispatch({ type: PRODUCT_ACTIONS.SET_LOADING, payload: true });\n    dispatch({ type: PRODUCT_ACTIONS.SET_ERROR, payload: null });\n    try {\n      const response = await apiClient.getAppointments();\n      if (response.success && response.data) {\n        dispatch({ type: PRODUCT_ACTIONS.SET_APPOINTMENTS, payload: Array.isArray(response.data) ? response.data : [] });\n      } else {\n        dispatch({ type: PRODUCT_ACTIONS.SET_APPOINTMENTS, payload: [] });\n      }\n    } catch (error: any) {\n      console.error('Error fetching appointments:', error);\n      dispatch({ type: PRODUCT_ACTIONS.SET_ERROR, payload: error.message || 'Failed to load appointments.' });\n    } finally {\n      dispatch({ type: PRODUCT_ACTIONS.SET_LOADING, payload: false });\n    }\n  }, []);\n\n  // Create order\n  const createOrder = useCallback(async (orderData: any) => {\n    dispatch({ type: PRODUCT_ACTIONS.SET_LOADING, payload: true });\n    dispatch({ type: PRODUCT_ACTIONS.SET_ERROR, payload: null });\n    try {\n      const response = await apiClient.createOrder(orderData);\n      if (response.success && response.data) {\n        dispatch({ type: PRODUCT_ACTIONS.ADD_ORDER, payload: response.data });\n        return response.data;\n      }\n      throw new Error(response.error || 'Failed to create order');\n    } catch (error: any) {\n      console.error('Error creating order:', error);\n      dispatch({ type: PRODUCT_ACTIONS.SET_ERROR, payload: error.message || 'Failed to create order.' });\n      throw error;\n    } finally {\n      dispatch({ type: PRODUCT_ACTIONS.SET_LOADING, payload: false });\n    }\n  }, []);\n\n  // Create appointment\n  const createAppointment = useCallback(async (appointmentData: any) => {\n    dispatch({ type: PRODUCT_ACTIONS.SET_LOADING, payload: true });\n    dispatch({ type: PRODUCT_ACTIONS.SET_ERROR, payload: null });\n    try {\n      const response = await apiClient.createAppointment(appointmentData);\n      if (response.success && response.data) {\n        dispatch({ type: PRODUCT_ACTIONS.SET_APPOINTMENTS, payload: [response.data, ...state.appointments] });\n        return response.data;\n      }\n      throw new Error(response.error || 'Failed to create appointment');\n    } catch (error: any) {\n      console.error('Error creating appointment:', error);\n      dispatch({ type: PRODUCT_ACTIONS.SET_ERROR, payload: error.message || 'Failed to create appointment.' });\n      throw error;\n    } finally {\n      dispatch({ type: PRODUCT_ACTIONS.SET_LOADING, payload: false });\n    }\n  }, [state.appointments]);\n\n  // Update product\n  const updateProduct = useCallback(async (id: number, data: any) => {\n    dispatch({ type: PRODUCT_ACTIONS.SET_LOADING, payload: true });\n    dispatch({ type: PRODUCT_ACTIONS.SET_ERROR, payload: null });\n    try {\n      const response = await apiClient.updateProduct(id, data);\n      if (response.success && response.data) {\n        dispatch({ type: PRODUCT_ACTIONS.SET_PRODUCTS, payload: state.products.map(p => p.id === id ? response.data : p) });\n        return response.data;\n      }\n      throw new Error(response.error || 'Failed to update product');\n    } catch (error: any) {\n      console.error('Error updating product:', error);\n      dispatch({ type: PRODUCT_ACTIONS.SET_ERROR, payload: error.message || 'Failed to update product.' });\n      throw error;\n    } finally {\n      dispatch({ type: PRODUCT_ACTIONS.SET_LOADING, payload: false });\n    }\n  }, [state.products]);\n\n  // Delete product\n  const deleteProduct = useCallback(async (id: number) => {\n    dispatch({ type: PRODUCT_ACTIONS.SET_LOADING, payload: true });\n    dispatch({ type: PRODUCT_ACTIONS.SET_ERROR, payload: null });\n    try {\n      const response = await apiClient.deleteProduct(id);\n      if (response.success) {\n        dispatch({ type: PRODUCT_ACTIONS.SET_PRODUCTS, payload: state.products.filter(p => p.id !== id) });\n        return true;\n      }\n      throw new Error(response.error || 'Failed to delete product');\n    } catch (error: any) {\n      console.error('Error deleting product:', error);\n      dispatch({ type: PRODUCT_ACTIONS.SET_ERROR, payload: error.message || 'Failed to delete product.' });\n      throw error;\n    } finally {\n      dispatch({ type: PRODUCT_ACTIONS.SET_LOADING, payload: false });\n    }\n  }, [state.products]);\n\n  // Create product\n  const createProduct = useCallback(async (productData: any) => {\n    dispatch({ type: PRODUCT_ACTIONS.SET_LOADING, payload: true });\n    dispatch({ type: PRODUCT_ACTIONS.SET_ERROR, payload: null });\n    try {\n      const response = await apiClient.createProduct(productData);\n      if (response.success && response.data) {\n        dispatch({ type: PRODUCT_ACTIONS.SET_PRODUCTS, payload: [response.data, ...state.products] });\n        return response.data;\n      }\n      throw new Error(response.error || 'Failed to create product');\n    } catch (error: any) {\n      console.error('Error creating product:', error);\n      dispatch({ type: PRODUCT_ACTIONS.SET_ERROR, payload: error.message || 'Failed to create product.' });\n      throw error;\n    } finally {\n      dispatch({ type: PRODUCT_ACTIONS.SET_LOADING, payload: false });\n    }\n  }, [state.products]);\n\n  return (\n    <ProductContext.Provider\n      value={{\n        products: state.products,\n        loading: state.loading,\n        error: state.error,\n        appointments: state.appointments,\n        orders: state.orders,\n        setProducts,\n        setLoading,\n        setError,\n        setAppointments,\n        setOrders,\n        fetchProducts,\n        fetchOrders,\n        fetchAppointments,\n        createOrder,\n        createAppointment,\n        updateProduct,\n        deleteProduct,\n        createProduct\n      }}\n    >\n      {children}\n    </ProductContext.Provider>\n  );\n};\n\nexport const useProduct = () => {\n  const context = useContext(ProductContext);\n  if (context === undefined) {\n    throw new Error('useProduct must be used within a ProductProvider');\n  }\n  return context;\n};","// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport const UIContext = registerClientReference(\n    function() { throw new Error(\"Attempted to call UIContext() from the server but UIContext is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/context/UIContext.tsx\",\n    \"UIContext\",\n);\nexport const UIProvider = registerClientReference(\n    function() { throw new Error(\"Attempted to call UIProvider() from the server but UIProvider is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/context/UIContext.tsx\",\n    \"UIProvider\",\n);\nexport const useUI = registerClientReference(\n    function() { throw new Error(\"Attempted to call useUI() from the server but useUI is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/context/UIContext.tsx\",\n    \"useUI\",\n);\n","'use client';\n\nimport React, { createContext, useContext, useReducer } from 'react';\n\ninterface LoadingState {\n  products: boolean;\n  cart: boolean;\n  orders: boolean;\n  appointments: boolean;\n  auth: boolean;\n  user: boolean;\n}\n\ninterface ErrorState {\n  products: string | null;\n  cart: string | null;\n  orders: string | null;\n  appointments: string | null;\n  auth: string | null;\n  user: string | null;\n}\n\ninterface UIState {\n  loading: LoadingState;\n  error: ErrorState;\n}\n\ninterface UIAction {\n  type: string;\n  payload?: any;\n}\n\n// Action types\nconst UI_ACTIONS = {\n  SET_LOADING: 'SET_LOADING',\n  SET_ERROR: 'SET_ERROR',\n  CLEAR_ERROR: 'CLEAR_ERROR'\n};\n\n// Initial state\nconst initialState: UIState = {\n  loading: {\n    products: false,\n    cart: false,\n    orders: false,\n    appointments: false,\n    auth: false,\n    user: false\n  },\n  error: {\n    products: null,\n    cart: null,\n    orders: null,\n    appointments: null,\n    auth: null,\n    user: null\n  }\n};\n\n// Reducer\nconst uiReducer = (state: UIState, action: UIAction): UIState => {\n  switch (action.type) {\n    case UI_ACTIONS.SET_LOADING:\n      return {\n        ...state,\n        loading: {\n          ...state.loading,\n          [action.payload.type]: action.payload.value\n        }\n      };\n    case UI_ACTIONS.SET_ERROR:\n      return {\n        ...state,\n        error: {\n          ...state.error,\n          [action.payload.type]: action.payload.value\n        }\n      };\n    case UI_ACTIONS.CLEAR_ERROR:\n      return {\n        ...state,\n        error: {\n          ...state.error,\n          [action.payload.type]: null\n        }\n      };\n    default:\n      return state;\n  }\n};\n\n// Create context\nexport const UIContext = createContext<{\n  loading: LoadingState;\n  error: ErrorState;\n  setLoading: (type: keyof LoadingState, value: boolean) => void;\n  setError: (type: keyof ErrorState, value: string | null) => void;\n  clearError: (type: keyof ErrorState) => void;\n} | undefined>(undefined);\n\n// Provider component\ninterface UIProviderProps {\n  children: React.ReactNode;\n}\n\nexport const UIProvider: React.FC<UIProviderProps> = ({ children }) => {\n  const [state, dispatch] = useReducer(uiReducer, initialState);\n\n  const setLoading = (type: keyof LoadingState, value: boolean) => {\n    dispatch({ type: UI_ACTIONS.SET_LOADING, payload: { type, value } });\n  };\n\n  const setError = (type: keyof ErrorState, value: string | null) => {\n    dispatch({ type: UI_ACTIONS.SET_ERROR, payload: { type, value } });\n  };\n\n  const clearError = (type: keyof ErrorState) => {\n    dispatch({ type: UI_ACTIONS.CLEAR_ERROR, payload: { type } });\n  };\n\n  return (\n    <UIContext.Provider\n      value={{\n        loading: state.loading,\n        error: state.error,\n        setLoading,\n        setError,\n        clearError\n      }}\n    >\n      {children}\n    </UIContext.Provider>\n  );\n};\n\nexport const useUI = () => {\n  const context = useContext(UIContext);\n  if (context === undefined) {\n    throw new Error('useUI must be used within a UIProvider');\n  }\n  return context;\n};","// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport const AppProvider = registerClientReference(\n    function() { throw new Error(\"Attempted to call AppProvider() from the server but AppProvider is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/context/AppProvider.tsx\",\n    \"AppProvider\",\n);\n","'use client';\n\nimport React from 'react';\nimport { AuthProvider } from './AuthContext';\nimport { CartProvider } from './CartContext';\nimport { ProductProvider } from './ProductContext';\nimport { UIProvider } from './UIContext';\n\n// Main provider that composes all individual context providers\nexport const AppProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {\n  return (\n    <UIProvider>\n      <AuthProvider>\n        <ProductProvider>\n          <CartProvider>\n            {children}\n          </CartProvider>\n        </ProductProvider>\n      </AuthProvider>\n    </UIProvider>\n  );\n};","import cssModule from \"@vercel/turbopack-next/internal/font/google/cssmodule.module.css?{%22path%22:%22layout.tsx%22,%22import%22:%22Playfair_Display%22,%22arguments%22:[{%22subsets%22:[%22latin%22],%22variable%22:%22--font-playfair%22,%22weight%22:[%22400%22,%22500%22,%22600%22,%22700%22,%22800%22,%22900%22]}],%22variableName%22:%22playfair%22}\";\nconst fontData = {\n    className: cssModule.className,\n    style: {\n        fontFamily: \"'Playfair Display', 'Playfair Display Fallback'\",\n        fontStyle: \"normal\",\n\n    },\n};\n\nif (cssModule.variable != null) {\n    fontData.variable = cssModule.variable;\n}\n\nexport default fontData;\n","import cssModule from \"@vercel/turbopack-next/internal/font/google/cssmodule.module.css?{%22path%22:%22layout.tsx%22,%22import%22:%22Montserrat%22,%22arguments%22:[{%22subsets%22:[%22latin%22],%22variable%22:%22--font-montserrat%22,%22weight%22:[%22300%22,%22400%22,%22500%22,%22600%22,%22700%22]}],%22variableName%22:%22montserrat%22}\";\nconst fontData = {\n    className: cssModule.className,\n    style: {\n        fontFamily: \"'Montserrat', 'Montserrat Fallback'\",\n        fontStyle: \"normal\",\n\n    },\n};\n\nif (cssModule.variable != null) {\n    fontData.variable = cssModule.variable;\n}\n\nexport default fontData;\n","// Modular Context System\n// This file now serves as an index for the modular context system.\n// The original monolithic AppContext has been split into smaller, focused contexts:\n// \n// - AuthContext: Handles authentication state (user, token, login, logout)\n// - CartContext: Manages shopping cart functionality\n// - ProductContext: Handles products, orders, and appointments\n// - UIContext: Manages UI state (loading, errors)\n//\n// To use these contexts in your components, import the specific context you need:\n//\n// import { useAuth } from '@/context/AuthContext';\n// import { useCart } from '@/context/CartContext';\n// import { useProduct } from '@/context/ProductContext';\n// import { useUI } from '@/context/UIContext';\n\nexport { useAuth } from './AuthContext';\nexport { useCart } from './CartContext';\nexport { useProduct } from './ProductContext';\nexport { useUI } from './UIContext';\nexport { AppProvider } from './AppProvider';\nexport { useAppContext } from './CombinedAppContext';","import cssModule from \"@vercel/turbopack-next/internal/font/google/cssmodule.module.css?{%22path%22:%22layout.tsx%22,%22import%22:%22Inter%22,%22arguments%22:[{%22subsets%22:[%22latin%22]}],%22variableName%22:%22inter%22}\";\nconst fontData = {\n    className: cssModule.className,\n    style: {\n        fontFamily: \"'Inter', 'Inter Fallback'\",\n        fontStyle: \"normal\",\n\n    },\n};\n\nif (cssModule.variable != null) {\n    fontData.variable = cssModule.variable;\n}\n\nexport default fontData;\n","import './globals.css';\nimport type { Metadata, Viewport } from 'next';\nimport { Inter, Playfair_Display, Montserrat } from 'next/font/google';\nimport { AppProvider } from '@/context/AppContext';\nimport '@fortawesome/fontawesome-free/css/all.css';\nconst inter = Inter({\n  subsets: ['latin']\n});\nconst playfair = Playfair_Display({\n  subsets: ['latin'],\n  variable: '--font-playfair',\n  weight: ['400', '500', '600', '700', '800', '900']\n});\nconst montserrat = Montserrat({\n  subsets: ['latin'],\n  variable: '--font-montserrat',\n  weight: ['300', '400', '500', '600', '700']\n});\nexport const viewport: Viewport = {\n  width: 'device-width',\n  initialScale: 1,\n  maximumScale: 5\n};\nexport const metadata: Metadata = {\n  title: 'Colour My Space - Interior Design Studio',\n  description: 'Premium interior design services and curated product collection. Transform your space with expert guidance from our experienced designers.',\n  keywords: ['interior design', 'home decor', 'furniture', 'design studio', 'consultation'],\n  authors: [{\n    name: 'Colour My Space'\n  }],\n  openGraph: {\n    type: 'website',\n    locale: 'en_US',\n    siteName: 'Colour My Space',\n    title: 'Colour My Space - Interior Design Studio',\n    description: 'Premium interior design services and curated product collection. Transform your space with expert guidance.',\n    images: [{\n      url: '/og-image.svg',\n      width: 1200,\n      height: 630,\n      alt: 'Colour My Space - Interior Design Studio'\n    }]\n  },\n  twitter: {\n    card: 'summary_large_image',\n    title: 'Colour My Space - Interior Design Studio',\n    description: 'Premium interior design services and curated product collection.',\n    images: ['/og-image.svg']\n  }\n};\nexport default function RootLayout({\n  children\n}: {\n  children: React.ReactNode;\n}) {\n  return <html lang=\"en\">\n      <body className={`${inter.className} ${playfair.variable} ${montserrat.variable}`}>\n        <AppProvider>\n          {children}\n        </AppProvider>\n        {/* This is the portal root for modals */}\n        <div id=\"modal-root\" />\n      </body>\n    </html>;\n}","import { useAuth } from './AuthContext';\nimport { useProduct } from './ProductContext';\nimport { useCart } from './CartContext';\nimport { useUI } from './UIContext';\n\n// Define the types based on UIContext interface\ninterface LoadingState {\n  products: boolean;\n  cart: boolean;\n  orders: boolean;\n  appointments: boolean;\n  auth: boolean;\n  user: boolean;\n}\ninterface ErrorState {\n  products: string | null;\n  cart: string | null;\n  orders: string | null;\n  appointments: string | null;\n  auth: string | null;\n  user: string | null;\n}\n\n// Define the combined context interface\ninterface CombinedAppContext {\n  // Auth context\n  user: any;\n  token: string | null;\n  loading: any;\n  error: string | null;\n  setUser: (user: any) => void;\n  setToken: (token: string | null) => void;\n  setLoading: (loading: any) => void;\n  setError: (error: string | null) => void;\n  logout: () => void;\n  signInWithGoogle: () => Promise<void>;\n\n  // Product context\n  products: any[];\n  orders: any[];\n  appointments: any[];\n  fetchProducts: () => Promise<void>;\n  fetchOrders: () => Promise<void>;\n  fetchAppointments: () => Promise<void>;\n  createOrder: (orderData: any) => Promise<any>;\n  createAppointment: (appointmentData: any) => Promise<any>;\n  updateProduct: (id: number, data: any) => Promise<any>;\n  deleteProduct: (id: number) => Promise<any>;\n  createProduct: (productData: any) => Promise<any>;\n\n  // Cart context\n  cartItems: any[];\n  cartCount: number;\n  cartTotal: number;\n  addItem: (item: any) => void;\n  updateItem: (productId: number, quantity: number) => void;\n  removeItem: (productId: number) => void;\n  clearCart: () => void;\n  addToCartWithAuth: (product: any, quantity: number) => any;\n\n  // UI context (adapting to match the actual UIContext interface)\n  uiLoading: LoadingState;\n  uiError: ErrorState;\n  setUILoading: (type: keyof LoadingState, value: boolean) => void;\n  setUIError: (type: keyof ErrorState, value: string | null) => void;\n}\nexport const useAppContext = (): CombinedAppContext => {\n  const auth = useAuth();\n  const product = useProduct();\n  const cart = useCart();\n  const ui = useUI();\n\n  // Create a function to add to cart with authentication check\n  const addToCartWithAuth = (product: any, quantity: number) => {\n    if (!auth.user) {\n      // Not authenticated\n      return {\n        success: false,\n        requiresLogin: true,\n        product,\n        quantity\n      };\n    }\n\n    // User is authenticated, add to cart\n    cart.addItem({\n      id: Date.now(),\n      // temporary ID for cart item\n      product_id: product.id,\n      quantity: quantity,\n      name: product.name,\n      price: product.price,\n      image_url: product.image_url\n    });\n    return {\n      success: true,\n      requiresLogin: false\n    };\n  };\n  return {\n    // Auth context\n    user: auth.user,\n    token: auth.token,\n    loading: auth.loading,\n    error: auth.error,\n    setUser: auth.setUser,\n    setToken: auth.setToken,\n    setLoading: auth.setLoading,\n    setError: auth.setError,\n    logout: auth.logout,\n    signInWithGoogle: auth.signInWithGoogle,\n    // Product context\n    products: product.products,\n    orders: product.orders,\n    appointments: product.appointments,\n    fetchProducts: product.fetchProducts,\n    fetchOrders: product.fetchOrders,\n    fetchAppointments: product.fetchAppointments,\n    createOrder: product.createOrder,\n    createAppointment: product.createAppointment,\n    updateProduct: product.updateProduct,\n    deleteProduct: product.deleteProduct,\n    createProduct: product.createProduct,\n    // Cart context\n    cartItems: cart.items,\n    cartCount: cart.cartCount,\n    cartTotal: cart.cartTotal,\n    addItem: cart.addItem,\n    updateItem: cart.updateItem,\n    removeItem: cart.removeItem,\n    clearCart: cart.clearCart,\n    addToCartWithAuth,\n    // UI context (adapting to match the actual UIContext interface)\n    uiLoading: ui.loading,\n    uiError: ui.error,\n    setUILoading: ui.setLoading,\n    setUIError: ui.setError\n  };\n};"],"names":["React","createContext","useContext","useReducer","useCallback","useEffect","User","signInWithGoogle","googleSignIn","signOut","onAuthStateChange","getCurrentUser","getUserProfile","AuthState","user","token","loading","error","AuthAction","type","payload","initialState","authReducer","state","action","AuthContext","undefined","AuthProvider","children","ReactNode","dispatch","setUser","u","setToken","t","setLoading","l","setError","e","logout","err","message","console","log","checkCurrentSession","useCartStore","getState","loadServerCart","cartError","sub","event","session","setState","items","handleWindowFocus","window","addEventListener","removeEventListener","unsubscribe","useAuth","ctx","Error","CartContext","cartCount","cartTotal","addItem","item","updateItem","productId","quantity","removeItem","clearCart","CartItem","id","product_id","name","price","image_url","CartProviderProps","CartProvider","FC","getTotalItems","getTotalPrice","useCart","context","apiClient","ProductState","products","appointments","orders","ProductAction","PRODUCT_ACTIONS","SET_PRODUCTS","SET_LOADING","SET_ERROR","SET_APPOINTMENTS","SET_ORDERS","ADD_ORDER","productReducer","Array","isArray","ProductContext","setProducts","setAppointments","setOrders","fetchProducts","Promise","fetchOrders","fetchAppointments","createOrder","orderData","createAppointment","appointmentData","updateProduct","data","deleteProduct","createProduct","productData","ProductProviderProps","ProductProvider","response","getProducts","success","productsData","mapImageIdentifierToClass","identifier","lowerIdentifier","toLowerCase","includes","formattedProducts","map","product","parseFloat","startsWith","imageClass","warn","getOrders","getAppointments","p","filter","useProduct","LoadingState","cart","auth","ErrorState","UIState","UIAction","UI_ACTIONS","CLEAR_ERROR","uiReducer","value","UIContext","clearError","UIProviderProps","UIProvider","useUI","AppProvider"],"mappings":"0BAAA,EAAA,CAAA,CAAA,CACA,UAAA,0CACA,cCFA,EAAA,CAAA,CAAA,CACA,UAAA,sDACA,SAAA,oDACA,cCHA,EAAA,CAAA,CAAA,CACA,UAAA,gDACA,SAAA,8CACA,2BCFA,IAAA,EAAA,EAAA,CAAA,CAAA,OACO,IAAM,EAAc,CAAA,EAAA,EAAA,uBAAA,AAAuB,EAC9C,WAAa,MAAM,AAAI,MAAM,oOAAsO,EACnQ,4DACA,eAES,EAAe,CAAA,EAAA,EAAA,uBAAA,AAAuB,EAC/C,WAAa,MAAM,AAAI,MAAM,sOAAwO,EACrQ,4DACA,gBAES,EAAU,CAAA,EAAA,EAAA,uBAAA,AAAuB,EAC1C,WAAa,MAAU,AAAJ,MAAU,4NAA8N,EAC3P,4DACA,6FAdJ,IAAA,EAAA,EAAA,CAAA,CAAA,OACO,IAAM,EAAc,CAAA,EAAA,EAAA,uBAAA,AAAuB,EAC9C,WAAa,MAAM,AAAI,MAAM,oOAAsO,EACnQ,wCACA,eAES,EAAe,CAAA,EAAA,EAAA,uBAAuB,AAAvB,EACxB,WAAa,MAAM,AAAI,MAAM,sOAAwO,EACrQ,wCACA,gBAES,EAAU,CAAA,EAAA,EAAA,uBAAA,AAAuB,EAC1C,WAAa,MAAM,AAAI,MAAM,4NAA8N,EAC3P,wCACA,uJEdJ,IAAA,EAAA,EAAA,CAAA,CAAA,OACO,IAAM,EAAc,CAAA,EAAA,EAAA,uBAAA,AAAuB,EAC9C,WAAa,MAAM,AAAI,MAAM,oOAAsO,EACnQ,4DACA,eAES,EAAe,CAAA,EAAA,EAAA,uBAAA,AAAuB,EAC/C,WAAa,MAAM,AAAI,MAAM,sOAAwO,EACrQ,4DACA,gBAES,EAAU,CAAA,EAAA,EAAA,uBAAA,AAAuB,EAC1C,WAAa,MAAM,AAAI,MAAM,4NAA8N,EAC3P,4DACA,6FAdJ,IAAA,EAAA,EAAA,CAAA,CAAA,OACO,IAAM,EAAc,CAAA,EAAA,EAAA,uBAAA,AAAuB,EAC9C,WAAa,MAAM,AAAI,MAAM,oOAAsO,EACnQ,wCACA,eAES,EAAe,CAAA,EAAA,EAAA,uBAAuB,AAAvB,EACxB,WAAa,MAAM,AAAI,MAAM,sOAAwO,EACrQ,wCACA,gBAES,EAAU,CAAA,EAAA,EAAA,uBAAA,AAAuB,EAC1C,WAAa,MAAM,AAAI,MAAM,4NAA8N,EAC3P,wCACA,wJEdJ,IAAA,EAAA,EAAA,CAAA,CAAA,OACO,IAAM,EAAiB,CAAA,EAAA,EAAA,uBAAA,AAAuB,EACjD,WAAa,MAAM,AAAI,MAAM,0OAA4O,EACzQ,+DACA,kBAES,EAAkB,CAAA,EAAA,EAAA,uBAAA,AAAuB,EAClD,WAAa,MAAM,AAAI,MAAM,4OAA8O,EAC3Q,+DACA,mBAES,EAAa,CAAA,EAAA,EAAA,uBAAA,AAAuB,EAC7C,WAAa,MAAM,AAAI,MAAM,kOAAoO,EACjQ,+DACA,yGAdJ,IAAA,EAAA,EAAA,CAAA,CAAA,OACO,IAAM,EAAiB,CAAA,EAAA,EAAA,uBAAA,AAAuB,EACjD,WAAa,MAAM,AAAI,MAAM,0OAA4O,EACzQ,2CACA,kBAES,EAAkB,CAAA,EAAA,EAAA,uBAAA,AAAuB,EAClD,WAAa,MAAU,AAAJ,MAAU,4OAA8O,EAC3Q,2CACA,mBAES,EAAa,CAAA,EAAA,EAAA,uBAAA,AAAuB,EAC7C,WAAa,MAAM,AAAI,MAAM,kOAAoO,EACjQ,2CACA,oKEdJ,IAAA,EAAA,EAAA,CAAA,CAAA,OACO,IAAM,EAAY,CAAA,EAAA,EAAA,uBAAA,AAAuB,EAC5C,WAAa,MAAM,AAAI,MAAM,gOAAkO,EAC/P,0DACA,aAES,EAAa,CAAA,EAAA,EAAA,uBAAA,AAAuB,EAC7C,WAAa,MAAM,AAAI,MAAM,kOAAoO,EACjQ,0DACA,cAES,EAAQ,CAAA,EAAA,EAAA,uBAAuB,AAAvB,EACjB,WAAa,MAAM,AAAI,MAAM,wNAA0N,EACvP,0DACA,qFAdJ,IAAA,EAAA,EAAA,CAAA,CAAA,OACO,IAAM,EAAY,CAAA,EAAA,EAAA,uBAAuB,AAAvB,EACrB,WAAa,MAAM,AAAI,MAAM,gOAAkO,EAC/P,sCACA,aAES,EAAa,CAAA,EAAA,EAAA,uBAAA,AAAuB,EAC7C,WAAa,MAAU,AAAJ,MAAU,kOAAoO,EACjQ,sCACA,cAES,EAAQ,CAAA,EAAA,EAAA,uBAAA,AAAuB,EACxC,WAAa,MAAM,AAAI,MAAM,wNAA0N,EACvP,sCACA,gJEbG,IAAM,EAAc,CAAA,EAAA,AAD3B,EAAA,CAAA,CAAA,OAC2B,uBAAA,AAAuB,EAC9C,WAAa,MAAM,AAAI,MAAM,oOAAsO,EACnQ,4DACA,gEAHG,IAAM,EAAc,CAAA,EAD3B,AAC2B,EAD3B,CAAA,CAAA,OAC2B,uBAAuB,AAAvB,EACvB,WAAa,MAAM,AAAI,MAAM,oOAAsO,EACnQ,wCACA,2IKLJ,EAAA,EAAA,CAAA,CAAA,OACA,IAAM,EAAW,CACb,UAAW,EAAA,OAAS,CAAC,SAAS,CAC9B,MAAO,CACH,WAAY,4BACZ,UAAW,QAEf,CACJ,CAE0B,MAAM,CAA5B,EAAA,OAAS,CAAC,QAAQ,GAClB,EAAS,QAAQ,CAAG,EAAA,OAAS,CAAC,QAAA,AAAQ,EHX1C,IAAA,EAAA,EAAA,CAAA,CAAA,OACA,IAAM,EAAW,CACb,UAAW,EAAA,OAAS,CAAC,SAAS,CAC9B,MAAO,CACH,WAAY,kDACZ,UAAW,QAEf,CACJ,CAE0B,MAAM,CAA5B,EAAA,OAAS,CAAC,QAAQ,GAClB,EAAS,QAAQ,CAAG,EAAA,OAAS,CAAC,QAAA,AAAQ,ECX1C,IAAA,EAAA,EAAA,CAAA,CAAA,OACA,IAAM,EAAW,CACb,UAAW,EAAA,OAAS,CAAC,SAAS,CAC9B,MAAO,CACH,WAAY,sCACZ,UAAW,QAEf,CACJ,CAE0B,MAAM,CAA5B,EAAA,OAAS,CAAC,QAAQ,GAClB,EAAS,QAAQ,CAAG,EAAA,OAAS,CAAC,QAAA,AAAQ,ECK1C,EAAA,CAAA,CAAA,MACA,EAAA,CAAA,CAAA,OACA,EAAA,CAAA,CAAA,OACA,EAAA,CAAA,CAAA,OACA,IAAA,EAAA,EAAA,CAAA,CAAA,OE8Be,SAAS,EAAW,UACjC,CAAQ,CAGT,EACC,MAAO,CAAA,EAAA,EAAA,GAAA,EAAC,OAAA,CAAK,KAAK,cACd,CAAA,EAAA,EAAA,IAAA,EAAC,OAAA,CAAK,UAAW,CAAA,ED1CR,AC0CW,EAAM,SAAS,CAAC,CAAC,EAAE,AJ1C9B,EI0CuC,QAAQ,CAAC,CAAC,EH1CjD,AG0CmD,EAAW,QAAQ,CAAA,CAAE,WAC/E,CAAA,EAAA,EAAA,GAAA,EAAC,EAAA,WAAW,CAAA,UACT,IAGH,CAAA,EAAA,EAAA,GAAA,EAAC,MAAA,CAAI,GAAG,mBAGhB,mCAzCkC,CAChC,MAAO,2CACP,YAAa,6IACb,SAAU,CAAC,kBAAmB,aAAc,YAAa,gBAAiB,eAAe,CACzF,QAAS,CAAC,CACR,KAAM,iBACR,EAAE,CACF,UAAW,CACT,KAAM,UACN,OAAQ,QACR,SAAU,kBACV,MAAO,2CACP,YAAa,8GACb,OAAQ,CAAC,CACP,IAAK,gBACL,MAAO,KACP,OAAQ,IACR,IAAK,0CACP,EAAE,AACJ,EACA,QAAS,CACP,KAAM,sBACN,MAAO,2CACP,YAAa,mEACb,OAAQ,CAAC,gBAAgB,AAC3B,CACF,eA/BkC,CAChC,MAAO,eACP,aAAc,EACd,aAAc,CAChB","ignoreList":[0,1,2,3,5,7,9,11,13,14,16]}
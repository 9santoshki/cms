{"version":3,"sources":["turbopack:///[next]/internal/font/google/inter_5972bc34.module.css [app-rsc] (css module)","turbopack:///[next]/internal/font/google/playfair_display_a6b1faec.module.css [app-rsc] (css module)","turbopack:///[next]/internal/font/google/montserrat_14730532.module.css [app-rsc] (css module)","turbopack:///[project]/src/context/AppContext.tsx/__nextjs-internal-proxy.mjs","turbopack:///[project]/src/context/AppContext.tsx","turbopack:///[project]/src/components/NextAuthProvider.tsx/__nextjs-internal-proxy.mjs","turbopack:///[project]/src/components/NextAuthProvider.tsx","turbopack:///[next]/internal/font/google/playfair_display_a6b1faec.js","turbopack:///[next]/internal/font/google/montserrat_14730532.js","turbopack:///[next]/internal/font/google/inter_5972bc34.js","turbopack:///[project]/src/app/layout.tsx"],"sourcesContent":["__turbopack_context__.v({\n  \"className\": \"inter_5972bc34-module__OU16Qa__className\",\n});\n","__turbopack_context__.v({\n  \"className\": \"playfair_display_a6b1faec-module__v-9lQG__className\",\n  \"variable\": \"playfair_display_a6b1faec-module__v-9lQG__variable\",\n});\n","__turbopack_context__.v({\n  \"className\": \"montserrat_14730532-module__3Wk8jq__className\",\n  \"variable\": \"montserrat_14730532-module__3Wk8jq__variable\",\n});\n","// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport const AppContext = registerClientReference(\n    function() { throw new Error(\"Attempted to call AppContext() from the server but AppContext is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/context/AppContext.tsx\",\n    \"AppContext\",\n);\nexport const AppProvider = registerClientReference(\n    function() { throw new Error(\"Attempted to call AppProvider() from the server but AppProvider is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/context/AppContext.tsx\",\n    \"AppProvider\",\n);\nexport const useAppContext = registerClientReference(\n    function() { throw new Error(\"Attempted to call useAppContext() from the server but useAppContext is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/context/AppContext.tsx\",\n    \"useAppContext\",\n);\n","'use client';\n\nimport React, { createContext, useContext, useReducer, useEffect, useRef } from 'react';\nimport { apiClient } from '@/lib/api';\nimport { User, Product, CartItem, Order, LoadingState, ErrorState, State } from '@/types';\nimport { getCurrentUser, onAuthStateChange, getUserProfile } from '@/lib/supabase/auth';\n\n// Action types\ninterface Action {\n  type: string;\n  payload?: any;\n}\n\n// Initial state\nconst initialState: State = {\n  user: null,\n  token: null,\n  products: [],\n  cartItems: [],\n  orders: [],\n  appointments: [],\n  loading: {\n    products: false,\n    cart: false,\n    orders: false,\n    appointments: false,\n    auth: false,\n    user: false\n  },\n  error: {\n    products: null,\n    cart: null,\n    orders: null,\n    appointments: null,\n    auth: null,\n    user: null\n  }\n};\n\n// Action types\nconst ACTIONS = {\n  SET_USER: 'SET_USER',\n  SET_TOKEN: 'SET_TOKEN',\n  SET_PRODUCTS: 'SET_PRODUCTS',\n  SET_CART_ITEMS: 'SET_CART_ITEMS',\n  SET_ORDERS: 'SET_ORDERS',\n  SET_APPOINTMENTS: 'SET_APPOINTMENTS',\n  SET_LOADING: 'SET_LOADING',\n  SET_ERROR: 'SET_ERROR',\n  ADD_TO_CART: 'ADD_TO_CART',\n  REMOVE_FROM_CART: 'REMOVE_FROM_CART',\n  UPDATE_CART_ITEM: 'UPDATE_CART_ITEM',\n  CLEAR_CART: 'CLEAR_CART',\n  ADD_ORDER: 'ADD_ORDER'\n};\n\n// Reducer\nconst appReducer = (state: State, action: Action): State => {\n  switch (action.type) {\n    case ACTIONS.SET_USER:\n      return {\n        ...state,\n        user: action.payload\n      };\n\n    case ACTIONS.SET_TOKEN:\n      return {\n        ...state,\n        token: action.payload\n      };\n\n    case ACTIONS.SET_PRODUCTS:\n      return {\n        ...state,\n        products: action.payload\n      };\n\n    case ACTIONS.SET_CART_ITEMS:\n      return {\n        ...state,\n        cartItems: action.payload\n      };\n\n    case ACTIONS.SET_ORDERS:\n      return {\n        ...state,\n        orders: action.payload\n      };\n\n    case ACTIONS.SET_APPOINTMENTS:\n      return {\n        ...state,\n        appointments: action.payload\n      };\n\n    case ACTIONS.SET_LOADING:\n      return {\n        ...state,\n        loading: {\n          ...state.loading,\n          [action.payload.type]: action.payload.value\n        },\n      };\n\n    case ACTIONS.SET_ERROR:\n      return {\n        ...state,\n        error: {\n          ...state.error,\n          [action.payload.type]: action.payload.value\n        }\n      };\n\n    case ACTIONS.ADD_TO_CART:\n      // The API response contains the final cart item with the updated quantity\n      // So we should update the existing item or add a new one\n      const existingItem = state.cartItems.find(item => item.product_id === action.payload.product_id);\n      let updatedCartItems: CartItem[];\n\n      if (existingItem) {\n        // Replace the existing item with the updated one from the API response\n        updatedCartItems = state.cartItems.map(item =>\n          item.product_id === action.payload.product_id ? action.payload : item\n        );\n      } else {\n        // Add the new item as returned by the API\n        updatedCartItems = [...state.cartItems, action.payload];\n      }\n\n      return {\n        ...state,\n        cartItems: updatedCartItems\n      };\n\n    case ACTIONS.UPDATE_CART_ITEM:\n      return {\n        ...state,\n        cartItems: state.cartItems.map(item =>\n          item.product_id === action.payload.product_id\n            ? { ...item, quantity: action.payload.quantity }\n            : item\n        )\n      };\n\n    case ACTIONS.REMOVE_FROM_CART:\n      return {\n        ...state,\n        cartItems: state.cartItems.filter(item => item.product_id !== action.payload)\n      };\n\n    case ACTIONS.CLEAR_CART:\n      return {\n        ...state,\n        cartItems: []\n      };\n\n    case ACTIONS.ADD_ORDER:\n      return {\n        ...state,\n        orders: [action.payload, ...state.orders]\n      };\n\n    default:\n      return state;\n  }\n};\n\n// Create context\nexport const AppContext = createContext<{\n  // State\n  user: User | null;\n  token: string | null;\n  products: Product[];\n  cartItems: CartItem[];\n  orders: Order[];\n  appointments: any[];\n  loading: LoadingState;\n  error: ErrorState;\n  // Actions\n  setUser: (user: User | null) => void;\n  setToken: (token: string | null) => void;\n  setLoading: (type: keyof LoadingState, value: boolean) => void;\n  setError: (type: keyof ErrorState, value: string | null) => void;\n  fetchProducts: () => Promise<void>;\n  fetchCartItems: () => Promise<void>;\n  addToCart: (product: Product, quantity?: number) => Promise<void>;\n  updateCartItem: (productId: number, quantity: number) => Promise<void>;\n  removeFromCart: (productId: number) => Promise<void>;\n  clearCart: () => Promise<void>;\n  fetchOrders: () => Promise<void>;\n  createOrder: (orderData: any) => Promise<any>;\n  login: (credentials: any) => Promise<any>;\n  register: (userData: any) => Promise<any>;\n  logout: () => void;\n  verifyToken: () => Promise<boolean>;\n  fetchUserProfile: () => Promise<any>;\n  updateUserProfile: (profileData: any) => Promise<any>;\n  createProduct: (productData: any) => Promise<any>;\n  updateProduct: (id: number, productData: any) => Promise<any>;\n  fetchProductBySlug: (slug: string) => Promise<Product>,\n  searchProducts: (params: {\n    q?: string;\n    search?: string;\n    category?: string;\n    minPrice?: number;\n    maxPrice?: number;\n    page?: number;\n    limit?: number;\n  }) => Promise<any>;\n  fetchAppointments: (filters?: {\n    status?: string;\n    date?: string;\n    page?: number;\n    limit?: number;\n  }) => Promise<any>;\n  createAppointment: (appointmentData: {\n    appointment_date: string;\n    notes?: string;\n  }) => Promise<any>;\n  updateAppointment: (id: string, updateData: {\n    status?: string;\n    notes?: string;\n  }) => Promise<any>;\n  addToCartWithAuth: (product: Product, quantity?: number) => {\n    success: boolean;\n    requiresLogin: boolean;\n    product?: Product;\n    quantity?: number;\n    action?: () => Promise<void>;\n  };\n  clearPendingCartAction: () => void;\n} | undefined>(undefined);\n\n// Provider component\ninterface AppProviderProps {\n  children: React.ReactNode;\n}\n\nexport const AppProvider: React.FC<AppProviderProps> = ({ children }) => {\n  const [state, dispatch] = useReducer(appReducer, initialState);\n  const tempSavedCart = useRef<CartItem[] | null>(null);\n\n  // DEBUG: Track initialization\n  console.log('ðŸ”„ AppContext initializing...');\n\n  // Load user from Supabase session on initial render\n  useEffect(() => {\n    let isMounted = true; // Flag to prevent state updates after unmount\n\n    const initializeAuth = async () => {\n      try {\n        const supabaseUser = await getCurrentUser();\n\n        if (isMounted && supabaseUser) {\n          // Get user profile from the profiles table\n          const userProfile = await getUserProfile();\n\n          if (userProfile) {\n            const userObject = {\n              id: userProfile.id,\n              name: supabaseUser.user_metadata?.full_name || supabaseUser.user_metadata?.name || supabaseUser.email?.split('@')[0] || 'User',\n              email: supabaseUser.email,\n              avatar: supabaseUser.user_metadata?.avatar || supabaseUser.user_metadata?.picture || null,\n              role: userProfile.role,\n              created_at: supabaseUser.created_at\n            };\n\n            if (isMounted) {\n              dispatch({ type: ACTIONS.SET_USER, payload: userObject });\n              localStorage.setItem('user', JSON.stringify(userObject));\n              console.log('âœ… User restored from Supabase session:', userObject);\n            }\n          } else {\n            // Fallback: use session data directly if profile fetch fails\n            const userObject = {\n              id: supabaseUser.id,\n              name: supabaseUser.user_metadata?.full_name || supabaseUser.user_metadata?.name || supabaseUser.email?.split('@')[0] || 'User',\n              email: supabaseUser.email,\n              avatar: supabaseUser.user_metadata?.avatar || supabaseUser.user_metadata?.picture || null,\n              role: 'customer', // Default role if profile doesn't exist yet\n              created_at: supabaseUser.created_at\n            };\n\n            if (isMounted) {\n              dispatch({ type: ACTIONS.SET_USER, payload: userObject });\n              localStorage.setItem('user', JSON.stringify(userObject));\n              console.log('âœ… User restored from Supabase session (fallback):', userObject);\n            }\n          }\n        } else if (isMounted) {\n          // No user in Supabase session, clear any local data\n          localStorage.removeItem('user');\n          console.log('âŒ No user in Supabase session, cleared user data');\n        }\n      } catch (error) {\n        console.error('Error initializing auth with Supabase:', error);\n        if (isMounted) {\n          localStorage.removeItem('user');\n          dispatch({ type: ACTIONS.SET_USER, payload: null });\n        }\n      }\n    };\n\n    initializeAuth();\n\n    // Set up auth state change listener\n    const unsubscribe = onAuthStateChange(async (event, session) => {\n      console.log('ðŸ” Auth state changed:', event);\n\n      if (isMounted && event === 'SIGNED_IN' && session?.user) {\n        // Get user profile from the profiles table\n        const userProfile = await getUserProfile();\n\n        if (userProfile) {\n          const userObject = {\n            id: userProfile.id,\n            name: session.user.user_metadata?.full_name || session.user.user_metadata?.name || session.user.email?.split('@')[0] || 'User',\n            email: session.user.email,\n            avatar: session.user.user_metadata?.avatar || session.user.user_metadata?.picture || null,\n            role: userProfile.role,\n            created_at: session.user.created_at\n          };\n\n          dispatch({ type: ACTIONS.SET_USER, payload: userObject });\n          localStorage.setItem('user', JSON.stringify(userObject));\n          console.log('âœ… User set after sign in:', userObject);\n        } else {\n          // Fallback: use session data directly if profile fetch fails\n          const userObject = {\n            id: session.user.id,\n            name: session.user.user_metadata?.full_name || session.user.user_metadata?.name || session.user.email?.split('@')[0] || 'User',\n            email: session.user.email,\n            avatar: session.user.user_metadata?.avatar || session.user.user_metadata?.picture || null,\n            role: 'customer', // Default role if profile doesn't exist yet\n            created_at: session.user.created_at\n          };\n\n          dispatch({ type: ACTIONS.SET_USER, payload: userObject });\n          localStorage.setItem('user', JSON.stringify(userObject));\n          console.log('âœ… User set after sign in (fallback):', userObject);\n        }\n      } else if (isMounted && event === 'SIGNED_OUT') {\n        localStorage.removeItem('user');\n        localStorage.removeItem('cartItems');\n        dispatch({ type: ACTIONS.SET_USER, payload: null });\n        dispatch({ type: ACTIONS.SET_CART_ITEMS, payload: [] });\n        console.log('âœ… User cleared after sign out');\n      }\n    });\n\n    // Cleanup function\n    return () => {\n      isMounted = false;\n      unsubscribe && unsubscribe();\n    };\n  }, []);\n\n  // Fetch cart items\n  const fetchCartItems = async () => {\n    if (!state.user) {\n      // For guest users, always set cart to empty as requested\n      dispatch({ type: ACTIONS.SET_CART_ITEMS, payload: [] });\n      // Sync Zustand cart with empty array\n      import('@/store/cartStore').then((module) => {\n        module.useCartStore.getState().clearCart();\n      });\n      return;\n    }\n\n    setLoading('cart', true);\n    setError('cart', null);\n\n    try {\n      const response = await apiClient.getCartItems();\n      if (response.success && response.data) {\n        dispatch({ type: ACTIONS.SET_CART_ITEMS, payload: response.data });\n        // Sync Zustand cart with fetched data\n        import('@/store/cartStore').then((module) => {\n          module.useCartStore.getState().clearCart();\n          response.data.forEach(item => {\n            module.useCartStore.getState().addItem(item);\n          });\n        });\n      } else {\n        // Don't throw an error for empty cart, just log and handle gracefully\n        console.warn('No cart items found for user:', response.error);\n        dispatch({ type: ACTIONS.SET_CART_ITEMS, payload: [] });\n        // Sync Zustand cart with empty array\n        import('@/store/cartStore').then((module) => {\n          module.useCartStore.getState().clearCart();\n        });\n      }\n    } catch (error: any) {\n      // Handle network errors, etc.\n      console.error('Error fetching cart items:', error);\n      setError('cart', error.message || 'Failed to load cart items. Please try again later.');\n      // Still set empty cart to avoid breaking the UI\n      dispatch({ type: ACTIONS.SET_CART_ITEMS, payload: [] });\n      // Sync Zustand cart with empty array\n      import('@/store/cartStore').then((module) => {\n        module.useCartStore.getState().clearCart();\n      });\n    } finally {\n      setLoading('cart', false);\n    }\n  };\n\n  // Load cart from localStorage based on login state\n  useEffect(() => {\n    if (!state.user) {\n      // User is not logged in, set cart to empty to ensure it appears empty in the UI\n      dispatch({ type: ACTIONS.SET_CART_ITEMS, payload: [] });\n    } else {\n      // User is logged in, fetch their cart from the server\n      fetchCartItems();\n    }\n  }, [state.user]); // Re-run when user changes\n\n  // Sync Zustand cart with AppContext cart\n  useEffect(() => {\n    // Initialize Zustand cart from AppContext\n    import('@/store/cartStore').then((module) => {\n      const { items } = module.useCartStore.getState();\n      if (items.length === 0 && state.cartItems.length > 0) {\n        // If Zustand store is empty but AppContext has items, populate Zustand\n        state.cartItems.forEach(item => {\n          module.useCartStore.getState().addItem(item);\n        });\n      } else if (items.length > 0 && state.cartItems.length === 0) {\n        // If Zustand has items but AppContext is empty, populate AppContext\n        dispatch({ type: ACTIONS.SET_CART_ITEMS, payload: items });\n      }\n    });\n  }, [state.cartItems]);\n\n  // Save cart to localStorage only when not logged in\n  useEffect(() => {\n    // Only save guest cart to localStorage if not logged in\n    if (!state.user) {\n      localStorage.setItem('cartItems', JSON.stringify(state.cartItems));\n    }\n  }, [state.cartItems, state.user]);\n\n  // Actions\n  const setUser = (user: User | null) => {\n    dispatch({ type: ACTIONS.SET_USER, payload: user });\n    if (user) {\n      localStorage.setItem('user', JSON.stringify(user));\n    } else {\n      localStorage.removeItem('user');\n    }\n  };\n\n  const setToken = (token: string | null) => {\n    dispatch({ type: ACTIONS.SET_TOKEN, payload: token });\n    if (token) {\n      localStorage.setItem('token', token);\n    } else {\n      localStorage.removeItem('token');\n    }\n  };\n\n  const setLoading = (type: keyof LoadingState, value: boolean) => {\n    dispatch({ type: ACTIONS.SET_LOADING, payload: { type, value } });\n  };\n\n  const setError = (type: keyof ErrorState, value: string | null) => {\n    dispatch({ type: ACTIONS.SET_ERROR, payload: { type, value } });\n  };\n\n  // Fetch products\n  const fetchProducts = async () => {\n    // Don't fetch if already loading to prevent race conditions\n    if (state.loading.products) return;\n\n    setLoading('products', true);\n    setError('products', null);\n\n    try {\n      const response = await apiClient.getProducts();\n      if (response.success && response.data) {\n        // Handle the new response structure with pagination\n        const productsData = Array.isArray(response.data) ? response.data : response.data?.products || [];\n        \n        // Convert price strings to numbers for proper formatting\n        // Map mock image_url identifiers to appropriate imageClass values\n        const mapImageIdentifierToClass = (identifier: string) => {\n          if (!identifier) return 'modern';\n\n          const lowerIdentifier = identifier.toLowerCase();\n          if (lowerIdentifier.includes('modern') || lowerIdentifier.includes('coffee') || lowerIdentifier.includes('sofa')) {\n            return 'modern';\n          } else if (lowerIdentifier.includes('classic') || lowerIdentifier.includes('armchair')) {\n            return 'classic';\n          } else if (lowerIdentifier.includes('vintage') || lowerIdentifier.includes('lamp')) {\n            return 'coastal'; // Using coastal for lighting items\n          } else if (lowerIdentifier.includes('dining') || lowerIdentifier.includes('dresser')) {\n            return 'office'; // Using office for furniture items\n          } else if (lowerIdentifier.includes('wall') || lowerIdentifier.includes('art')) {\n            return 'hotel'; // Using hotel for decor items\n          } else if (lowerIdentifier.includes('rug')) {\n            return 'restaurant'; // Using restaurant for decor items\n          } else {\n            return 'modern'; // default\n          }\n        };\n\n        const formattedProducts = productsData.map((product: any) => ({\n          ...product,\n          price: typeof product.price === 'number' ? product.price : parseFloat(product.price),\n          // Only set image_url to undefined if it's not a proper URL\n          // If it looks like an actual URL (contains http), keep it\n          image_url: product.image_url && (product.image_url.startsWith('http') || product.image_url.startsWith('/'))\n            ? product.image_url\n            : undefined,\n          // Use the identifier to determine the appropriate CSS class\n          imageClass: mapImageIdentifierToClass(product.image_url) || product.imageClass || 'modern'\n        }));\n        dispatch({ type: ACTIONS.SET_PRODUCTS, payload: formattedProducts });\n      } else {\n        throw new Error(response.error || 'Failed to load products');\n      }\n    } catch (error: any) {\n      console.error('Error fetching products:', error);\n      setError('products', error.message || 'Failed to load products. Please try again later.');\n    } finally {\n      setLoading('products', false);\n    }\n  };\n\n  // Add item to cart\n  // Track ongoing cart requests to prevent duplicates\n  const ongoingCartRequests = new Set<number>(); // Set to track product IDs with ongoing requests\n\n  const addToCart = async (product: Product, quantity = 1) => {\n    // Prevent multiple requests for the same product\n    if (ongoingCartRequests.has(product.id)) {\n      return; // Skip if already processing a request for this product\n    }\n\n    if (state.user) {\n      ongoingCartRequests.add(product.id); // Mark this product as having an ongoing request\n      setLoading('cart', true);\n      setError('cart', null);\n\n      try {\n        const response = await apiClient.addToCart(product.id, quantity);\n        if (response.success && response.data) {\n          dispatch({ type: ACTIONS.ADD_TO_CART, payload: response.data });\n          // Sync with Zustand store\n          import('@/store/cartStore').then((module) => {\n            module.useCartStore.getState().addItem(response.data);\n          });\n        } else {\n          throw new Error(response.error || 'Failed to add item to cart');\n        }\n      } catch (error: any) {\n        console.error('Error adding to cart:', error);\n        setError('cart', error.message || 'Failed to add item to cart. Please try again.');\n      } finally {\n        ongoingCartRequests.delete(product.id); // Remove the tracking\n        setLoading('cart', false);\n      }\n    } else {\n      // For non-authenticated users, add to Zustand cart directly\n      const cartItem = {\n        id: Date.now(), // Temporary ID\n        product_id: product.id,\n        quantity,\n        name: product.name,\n        price: product.price,\n        image_url: product.image_url,\n      };\n      \n      import('@/store/cartStore').then((module) => {\n        module.useCartStore.getState().addItem(cartItem);\n      });\n    }\n  };\n\n  // Update cart item\n  const updateCartItem = async (productId: number, quantity: number) => {\n    // Only proceed if product ID is valid\n    if (!productId || typeof productId !== 'number' || productId <= 0) {\n      console.error('Invalid product ID provided to updateCartItem:', productId);\n      return;\n    }\n\n    if (state.user) {\n      setLoading('cart', true);\n      setError('cart', null);\n\n      try {\n        const response = await apiClient.updateCartItem(productId, quantity);\n        if (response.success && response.data) {\n          // Use ADD_TO_CART action to properly handle the full cart item data from API\n          // This will add a new item or update an existing one with the full API response data\n          dispatch({ type: ACTIONS.ADD_TO_CART, payload: response.data });\n          // Sync with Zustand store\n          import('@/store/cartStore').then((module) => {\n            module.useCartStore.getState().updateItem(product_id, quantity);\n          });\n        } else if (quantity <= 0 && response.success) {\n          // When quantity is 0, the item was removed\n          dispatch({ type: ACTIONS.REMOVE_FROM_CART, payload: product_id });\n          // Sync with Zustand store\n          import('@/store/cartStore').then((module) => {\n            module.useCartStore.getState().removeItem(product_id);\n          });\n        } else {\n          throw new Error(response.error || 'Failed to update cart item');\n        }\n      } catch (error: any) {\n        console.error('Error updating cart item:', error);\n        setError('cart', error.message || 'Failed to update cart item. Please try again.');\n      } finally {\n        setLoading('cart', false);\n      }\n    } else {\n      if (quantity <= 0) {\n        dispatch({ type: ACTIONS.REMOVE_FROM_CART, payload: productId });\n        // Sync with Zustand store\n        import('@/store/cartStore').then((module) => {\n          module.useCartStore.getState().removeItem(productId);\n        });\n      } else {\n        dispatch({ type: ACTIONS.UPDATE_CART_ITEM, payload: { product_id: productId, quantity } });\n        // Sync with Zustand store\n        import('@/store/cartStore').then((module) => {\n          module.useCartStore.getState().updateItem(productId, quantity);\n        });\n      }\n\n      // Update localStorage for guest cart\n      const currentCart = JSON.parse(localStorage.getItem('cartItems') || '[]');\n      const existingItemIndex = currentCart.findIndex((item: any) => item.product_id === productId);\n\n      if (existingItemIndex !== -1) {\n        if (quantity <= 0) {\n          // Remove item from localStorage\n          currentCart.splice(existingItemIndex, 1);\n        } else {\n          // Update quantity in localStorage\n          currentCart[existingItemIndex].quantity = quantity;\n        }\n      } else if (quantity > 0) {\n        // Find the product to get its details and add to localStorage\n        const product = state.products.find(p => p.id === productId);\n        if (product) {\n          currentCart.push({\n            id: product.id,\n            product_id: product.id,\n            name: product.name,\n            price: product.price,\n            quantity,\n            image_url: product.image_url,\n            user_id: null\n          });\n        }\n      }\n\n      localStorage.setItem('cartItems', JSON.stringify(currentCart));\n    }\n  };\n\n  // Remove item from cart\n  const removeFromCart = async (productId: number) => {\n    // Only proceed if product ID is valid\n    if (!productId || typeof productId !== 'number' || productId <= 0) {\n      console.error('Invalid product ID provided to removeFromCart:', productId);\n      return;\n    }\n\n    if (state.user) {\n      setLoading('cart', true);\n      setError('cart', null);\n\n      try {\n        const response = await apiClient.removeFromCart(productId);\n        if (response.success) {\n          dispatch({ type: ACTIONS.REMOVE_FROM_CART, payload: productId });\n          // Sync with Zustand store\n          import('@/store/cartStore').then((module) => {\n            module.useCartStore.getState().removeItem(productId);\n          });\n        } else {\n          throw new Error(response.error || 'Failed to remove item from cart');\n        }\n      } catch (error: any) {\n        console.error('Error removing from cart:', error);\n        setError('cart', error.message || 'Failed to remove item from cart. Please try again.');\n      } finally {\n        setLoading('cart', false);\n      }\n    } else {\n      dispatch({ type: ACTIONS.REMOVE_FROM_CART, payload: productId });\n      // Sync with Zustand store\n      import('@/store/cartStore').then((module) => {\n        module.useCartStore.getState().removeItem(productId);\n      });\n\n      // Update localStorage for guest cart\n      const currentCart = JSON.parse(localStorage.getItem('cartItems') || '[]');\n      const updatedCart = currentCart.filter((item: any) => item.product_id !== productId);\n      localStorage.setItem('cartItems', JSON.stringify(updatedCart));\n    }\n  };\n\n  // Clear cart\n  const clearCart = async () => {\n    if (state.user) {\n      setLoading('cart', true);\n      setError('cart', null);\n\n      try {\n        const response = await apiClient.clearCart();\n        if (response.success) {\n          dispatch({ type: ACTIONS.CLEAR_CART });\n          // Sync with Zustand store\n          import('@/store/cartStore').then((module) => {\n            module.useCartStore.getState().clearCart();\n          });\n        } else {\n          throw new Error(response.error || 'Failed to clear cart');\n        }\n      } catch (error: any) {\n        console.error('Error clearing cart:', error);\n        setError('cart', error.message || 'Failed to clear cart. Please try again.');\n      } finally {\n        setLoading('cart', false);\n      }\n    } else {\n      dispatch({ type: ACTIONS.CLEAR_CART });\n      // Sync with Zustand store\n      import('@/store/cartStore').then((module) => {\n        module.useCartStore.getState().clearCart();\n      });\n      // Clear localStorage for guest cart\n      localStorage.removeItem('cartItems');\n    }\n  };\n\n  // Fetch orders\n  const fetchOrders = async () => {\n    if (!state.user) return;\n\n    setLoading('orders', true);\n    setError('orders', null);\n\n    try {\n      const response = await apiClient.getOrders();\n      if (response.success && response.data) {\n        dispatch({ type: ACTIONS.SET_ORDERS, payload: response.data });\n      } else {\n        throw new Error(response.error || 'Failed to load orders');\n      }\n    } catch (error: any) {\n      console.error('Error fetching orders:', error);\n      setError('orders', error.message || 'Failed to load orders. Please try again later.');\n    } finally {\n      setLoading('orders', false);\n    }\n  };\n\n  // Create order\n  const createOrder = async (orderData: any) => {\n    if (!state.user) return;\n\n    setLoading('orders', true);\n    setError('orders', null);\n\n    try {\n      const response = await apiClient.createOrder(orderData);\n      if (response.success && response.data) {\n        dispatch({ type: ACTIONS.ADD_ORDER, payload: response.data });\n        dispatch({ type: ACTIONS.CLEAR_CART });\n        return response.data;\n      } else {\n        throw new Error(response.error || 'Failed to create order');\n      }\n    } catch (error: any) {\n      console.error('Error creating order:', error);\n\n      // Handle validation errors from backend\n      if (error.message && error.message.includes('Validation Error')) {\n        setError('orders', 'Please check your order details and try again.');\n      } else {\n        setError('orders', error.message || 'Failed to create order. Please try again.');\n      }\n\n      throw error;\n    } finally {\n      setLoading('orders', false);\n    }\n  };\n\n  // Fetch user profile\n  const fetchUserProfile = async () => {\n    if (!state.user) return;\n\n    setLoading('user', true);\n    setError('user', null);\n\n    try {\n      const response = await fetch('/api/profile', {\n        headers: {\n          'Authorization': `Bearer ${state.token}` // This might need to be updated for Supabase\n        }\n      });\n\n      const result = await response.json();\n      if (result.success && result.data) {\n        // Always update user in context with the latest data from the API\n        setUser(result.data);\n        return result.data;\n      } else {\n        // If API call fails, and we have existing user data, return that.\n        // Otherwise, throw an error.\n        if (state.user) {\n          return state.user;\n        } else {\n          throw new Error(result.error || 'Failed to fetch user profile');\n        }\n      }\n    } catch (error: any) {\n      console.error('Error fetching user profile:', error);\n      // If an error occurs and we have existing user data, return that.\n      // Otherwise, set an error.\n      if (state.user) {\n        return state.user;\n      }\n      setError('user', error.message || 'Failed to fetch user profile. Please try again later.');\n      throw error; // Re-throw to propagate the error for handling in components\n    } finally {\n      setLoading('user', false);\n    }\n  };\n\n\n\n  // Update user profile\n  const updateUserProfile = async (profileData: any) => {\n    if (!state.user) return;\n\n    setLoading('user', true);\n    setError('user', null);\n\n    try {\n      const response = await fetch('/api/profile', {\n        method: 'PUT',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${state.token}` // This might need to be updated for Supabase\n        },\n        body: JSON.stringify(profileData)\n      });\n\n      const result = await response.json();\n      if (result.success && result.data) {\n        // Update user in context\n        setUser(result.data);\n        return result.data;\n      } else {\n        throw new Error(result.error || 'Failed to update profile');\n      }\n    } catch (error: any) {\n      console.error('Error updating profile:', error);\n      setError('user', error.message || 'Failed to update profile. Please try again.');\n      throw error;\n    } finally {\n      setLoading('user', false);\n    }\n  };\n\n  // Login - This should be removed since we're using Google OAuth exclusively\n  const login = async (credentials: any) => {\n    throw new Error('Email/password login is not supported. Please use Google OAuth.');\n  };\n\n  // Register - This should be removed since we're using Google OAuth exclusively\n  const register = async (userData: any) => {\n    throw new Error('Email/password registration is not supported. Please use Google OAuth.');\n  };\n\n  // Logout\n  const logout = async () => {\n    try {\n      // Store the current cart in temp ref for potential restoration on login\n      tempSavedCart.current = [...state.cartItems];\n\n      // Clear cart items from localStorage to ensure cart appears empty after logout\n      localStorage.removeItem('cartItems');\n\n      // Clear user from app context\n      setUser(null);\n      setToken(null);\n      \n      // Clear all user-related data from localStorage\n      localStorage.removeItem('user');\n      localStorage.removeItem('token');\n      \n      // Dispatch actions to clear state\n      dispatch({ type: ACTIONS.CLEAR_CART });\n      dispatch({ type: ACTIONS.SET_ORDERS, payload: [] });\n      \n      // Also logout from Supabase to clear all session cookies\n      try {\n        const { createClient } = await import('@/lib/supabase/client');\n        const supabase = createClient();\n        const { error } = await supabase.auth.signOut();\n        if (error) {\n          console.error('Supabase sign out error:', error);\n        }\n      } catch (supabaseSignOutError) {\n        console.error('Error with main Supabase sign out:', supabaseSignOutError);\n      }\n      \n      // For good measure, also try to clear any possible remaining session data\n      // by calling the signOut function from auth utils which we updated\n      try {\n        const { signOut } = await import('@/lib/supabase/auth');\n        await signOut();\n      } catch (authSignOutError) {\n        // If auth signOut fails, that's ok as long as the main signOut worked\n        console.warn('Additional signOut failed (this is ok):', authSignOutError);\n      }\n      \n      // Reset the API client token to ensure it doesn't hold any auth data\n      try {\n        const { apiClient } = await import('@/lib/api');\n        apiClient.setToken(null);\n      } catch (apiClientError) {\n        console.warn('Error resetting API client token:', apiClientError);\n      }\n      \n      // Add a small delay to ensure all async operations complete\n      await new Promise(resolve => setTimeout(resolve, 300));\n    } catch (error) {\n      console.error('Error during logout:', error);\n    }\n  };\n\n  // Create product\n  const createProduct = async (productData: any) => {\n    if (!state.user) return;\n\n    setLoading('products', true);\n    setError('products', null);\n\n    try {\n      const response = await apiClient.createProduct(productData);\n      if (response.success && response.data) {\n        // Update products list to include the new product\n        dispatch({ type: ACTIONS.SET_PRODUCTS, payload: [...state.products, response.data] });\n        return response.data;\n      } else {\n        throw new Error(response.error || 'Failed to create product');\n      }\n    } catch (error: any) {\n      console.error('Error creating product:', error);\n      setError('products', error.message || 'Failed to create product. Please try again.');\n      throw error;\n    } finally {\n      setLoading('products', false);\n    }\n  };\n\n  // Update product\n  const updateProduct = async (id: number, productData: any) => {\n    if (!state.user) return;\n\n    setLoading('products', true);\n    setError('products', null);\n\n    try {\n      const response = await apiClient.updateProduct(id, productData);\n      if (response.success && response.data) {\n        // Update products list to reflect the changes\n        const updatedProducts = state.products.map(product =>\n          product.id === id ? response.data : product\n        );\n        dispatch({ type: ACTIONS.SET_PRODUCTS, payload: updatedProducts });\n        return response.data;\n      } else {\n        throw new Error(response.error || 'Failed to update product');\n      }\n    } catch (error: any) {\n      console.error('Error updating product:', error);\n      setError('products', error.message || 'Failed to update product. Please try again.');\n      throw error;\n    } finally {\n      setLoading('products', false);\n    }\n  };\n\n  // Fetch specific product by slug\n  const fetchProductBySlug = async (slug: string): Promise<Product> => {\n    setLoading('products', true);\n    setError('products', null);\n\n    try {\n      const response = await apiClient.getProductBySlug(slug);\n      if (response.success && response.data) {\n        // Ensure slug is present in the returned product\n        const productData: Product = {\n          ...response.data,\n          slug: response.data.slug || slug\n        };\n\n        // Add the fetched product to the products list\n        const updatedProducts = [...state.products];\n        const existingIndex = updatedProducts.findIndex(p => p.id === productData.id);\n\n        if (existingIndex !== -1) {\n          // Update existing product\n          updatedProducts[existingIndex] = productData;\n        } else {\n          // Add new product\n          updatedProducts.push(productData);\n        }\n\n        dispatch({ type: ACTIONS.SET_PRODUCTS, payload: updatedProducts });\n        return productData;\n      } else {\n        throw new Error(response.error || 'Failed to fetch product');\n      }\n    } catch (error: any) {\n      console.error('Error fetching product by slug:', error);\n      setError('products', error.message || 'Failed to fetch product. Please try again.');\n      throw error;\n    } finally {\n      setLoading('products', false);\n    }\n  };\n\n  // Search products\n  const searchProducts = async (params: {\n    q?: string;\n    search?: string;\n    category?: string;\n    minPrice?: number;\n    maxPrice?: number;\n    page?: number;\n    limit?: number;\n  }) => {\n    setLoading('products', true);\n    setError('products', null);\n\n    try {\n      const response = await apiClient.searchProducts(params);\n      if (response.success && response.data) {\n        // Handle both response formats (old direct array and new with pagination object)\n        const productsData = Array.isArray(response.data) ? response.data : response.data?.products || [];\n        \n        // Map imageClass to products\n        const mapImageIdentifierToClass = (identifier: string) => {\n          if (!identifier) return 'modern';\n\n          const lowerIdentifier = identifier.toLowerCase();\n          if (lowerIdentifier.includes('modern') || lowerIdentifier.includes('coffee') || lowerIdentifier.includes('sofa')) {\n            return 'modern';\n          } else if (lowerIdentifier.includes('classic') || lowerIdentifier.includes('armchair')) {\n            return 'classic';\n          } else if (lowerIdentifier.includes('vintage') || lowerIdentifier.includes('lamp')) {\n            return 'coastal'; // Using coastal for lighting items\n          } else if (lowerIdentifier.includes('dining') || lowerIdentifier.includes('dresser')) {\n            return 'office'; // Using office for furniture items\n          } else if (lowerIdentifier.includes('wall') || lowerIdentifier.includes('art')) {\n            return 'hotel'; // Using hotel for decor items\n          } else if (lowerIdentifier.includes('rug')) {\n            return 'restaurant'; // Using restaurant for decor items\n          } else {\n            return 'modern'; // default\n          }\n        };\n\n        const formattedProducts = productsData.map((product: any) => ({\n          ...product,\n          price: typeof product.price === 'number' ? product.price : parseFloat(product.price),\n          image_url: product.image_url && (product.image_url.startsWith('http') || product.image_url.startsWith('/'))\n            ? product.image_url\n            : undefined,\n          imageClass: mapImageIdentifierToClass(product.image_url) || product.imageClass || 'modern'\n        }));\n\n        dispatch({ type: ACTIONS.SET_PRODUCTS, payload: formattedProducts });\n        \n        // Return pagination data if it exists\n        if (response.data.pagination) {\n          return {\n            products: formattedProducts,\n            pagination: response.data.pagination,\n            filters: response.data.filters\n          };\n        } else {\n          return formattedProducts;\n        }\n      } else {\n        throw new Error(response.error || 'Failed to search products');\n      }\n    } catch (error: any) {\n      console.error('Error searching products:', error);\n      setError('products', error.message || 'Failed to search products. Please try again.');\n      throw error;\n    } finally {\n      setLoading('products', false);\n    }\n  };\n\n  // Verify token - we can use any authenticated endpoint to verify the token\n  const verifyToken = async () => {\n    if (!state.user) return false;\n\n    try {\n      // Using the getOrders endpoint as a way to verify the token\n      const response = await apiClient.getOrders();\n      if (response.success) {\n        return true;\n      } else {\n        throw new Error('Token verification failed');\n      }\n    } catch (error: any) {\n      console.error('Token verification failed:', error);\n      logout();\n      return false;\n    }\n  };\n\n  // Fetch appointments\n  const fetchAppointments = async (filters?: {\n    status?: string;\n    date?: string;\n    page?: number;\n    limit?: number;\n  }) => {\n    if (!state.user) return;\n\n    setLoading('appointments', true);\n    setError('appointments', null);\n\n    try {\n      const response = await apiClient.getAppointments(filters);\n      if (response.success && response.data) {\n        dispatch({ type: ACTIONS.SET_APPOINTMENTS, payload: response.data.appointments });\n        return response.data;\n      } else {\n        throw new Error(response.error || 'Failed to fetch appointments');\n      }\n    } catch (error: any) {\n      console.error('Error fetching appointments:', error);\n      setError('appointments', error.message || 'Failed to fetch appointments. Please try again.');\n      throw error;\n    } finally {\n      setLoading('appointments', false);\n    }\n  };\n\n  // Create appointment\n  const createAppointment = async (appointmentData: {\n    appointment_date: string;\n    notes?: string;\n  }) => {\n    if (!state.user) return;\n\n    try {\n      const response = await apiClient.createAppointment(appointmentData);\n      if (response.success && response.data) {\n        // Refresh appointments list after creating new one\n        await fetchAppointments();\n        return response.data;\n      } else {\n        throw new Error(response.error || 'Failed to create appointment');\n      }\n    } catch (error: any) {\n      console.error('Error creating appointment:', error);\n      throw error;\n    }\n  };\n\n  // Update appointment\n  const updateAppointment = async (id: string, updateData: {\n    status?: string;\n    notes?: string;\n  }) => {\n    if (!state.user) return;\n\n    try {\n      const response = await apiClient.updateAppointment(id, updateData);\n      if (response.success && response.data) {\n        // Refresh appointments list after updating\n        await fetchAppointments();\n        return response.data;\n      } else {\n        throw new Error(response.error || 'Failed to update appointment');\n      }\n    } catch (error: any) {\n      console.error('Error updating appointment:', error);\n      throw error;\n    }\n  };\n\n  // Clear pending cart action\n  const clearPendingCartAction = () => {\n    localStorage.removeItem('pendingCartAction');\n  };\n\n  // Add item to cart or request login if guest\n  const addToCartWithAuth = (product: Product, quantity = 1) => {\n    if (state.user) {\n      // User is logged in, return success and the cart action to be performed\n      return { success: true, requiresLogin: false, product, quantity, action: () => addToCart(product, quantity) };\n    } else {\n      // User is not logged in, indicate they need to log in\n      return { success: false, requiresLogin: true, product, quantity };\n    }\n  };\n\n  const value = {\n    ...state,\n    setUser,\n    setToken,\n    setLoading,\n    setError,\n    fetchProducts,\n    fetchCartItems,\n    addToCart,\n    updateCartItem,\n    removeFromCart,\n    clearCart,\n    fetchOrders,\n    createOrder,\n    fetchAppointments,\n    createAppointment,\n    updateAppointment,\n    login,\n    register,\n    logout,\n    verifyToken,\n    fetchUserProfile,\n    updateUserProfile,\n    createProduct,\n    updateProduct,\n    fetchProductBySlug,\n    searchProducts,\n    addToCartWithAuth,\n    clearPendingCartAction\n  };\n\n  return (\n    <AppContext.Provider value={value}>\n      {children}\n    </AppContext.Provider>\n  );\n};\n\n// Custom hook to use the context\nexport const useAppContext = () => {\n  const context = useContext(AppContext);\n  if (!context) {\n    throw new Error('useAppContext must be used within an AppProvider');\n  }\n  return context;\n};","// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport const NextAuthProvider = registerClientReference(\n    function() { throw new Error(\"Attempted to call NextAuthProvider() from the server but NextAuthProvider is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/components/NextAuthProvider.tsx\",\n    \"NextAuthProvider\",\n);\n","'use client';\n\nimport { SessionContextProvider } from '@/lib/supabase/SessionContextProvider';\nimport { createClient } from '@/lib/supabase/client';\n\nexport function NextAuthProvider({ children }: { children: React.ReactNode }) {\n  const supabase = createClient();\n\n  return (\n    <SessionContextProvider supabaseClient={supabase}>\n      {children}\n    </SessionContextProvider>\n  );\n}","import cssModule from \"@vercel/turbopack-next/internal/font/google/cssmodule.module.css?{%22path%22:%22layout.tsx%22,%22import%22:%22Playfair_Display%22,%22arguments%22:[{%22subsets%22:[%22latin%22],%22variable%22:%22--font-playfair%22,%22weight%22:[%22400%22,%22500%22,%22600%22,%22700%22,%22800%22,%22900%22]}],%22variableName%22:%22playfair%22}\";\nconst fontData = {\n    className: cssModule.className,\n    style: {\n        fontFamily: \"'Playfair Display', 'Playfair Display Fallback'\",\n        fontStyle: \"normal\",\n\n    },\n};\n\nif (cssModule.variable != null) {\n    fontData.variable = cssModule.variable;\n}\n\nexport default fontData;\n","import cssModule from \"@vercel/turbopack-next/internal/font/google/cssmodule.module.css?{%22path%22:%22layout.tsx%22,%22import%22:%22Montserrat%22,%22arguments%22:[{%22subsets%22:[%22latin%22],%22variable%22:%22--font-montserrat%22,%22weight%22:[%22300%22,%22400%22,%22500%22,%22600%22,%22700%22]}],%22variableName%22:%22montserrat%22}\";\nconst fontData = {\n    className: cssModule.className,\n    style: {\n        fontFamily: \"'Montserrat', 'Montserrat Fallback'\",\n        fontStyle: \"normal\",\n\n    },\n};\n\nif (cssModule.variable != null) {\n    fontData.variable = cssModule.variable;\n}\n\nexport default fontData;\n","import cssModule from \"@vercel/turbopack-next/internal/font/google/cssmodule.module.css?{%22path%22:%22layout.tsx%22,%22import%22:%22Inter%22,%22arguments%22:[{%22subsets%22:[%22latin%22]}],%22variableName%22:%22inter%22}\";\nconst fontData = {\n    className: cssModule.className,\n    style: {\n        fontFamily: \"'Inter', 'Inter Fallback'\",\n        fontStyle: \"normal\",\n\n    },\n};\n\nif (cssModule.variable != null) {\n    fontData.variable = cssModule.variable;\n}\n\nexport default fontData;\n","import './globals.css';\nimport type { Metadata } from 'next';\nimport { Inter, Playfair_Display, Montserrat } from 'next/font/google';\nimport { AppProvider } from '@/context/AppContext';\nimport { NextAuthProvider } from '@/components/NextAuthProvider';\nimport Script from 'next/script';\n\n// Import Font Awesome CSS\nimport '@fortawesome/fontawesome-free/css/all.css';\nconst inter = Inter({\n  subsets: ['latin']\n});\nconst playfair = Playfair_Display({\n  subsets: ['latin'],\n  variable: '--font-playfair',\n  weight: ['400', '500', '600', '700', '800', '900']\n});\nconst montserrat = Montserrat({\n  subsets: ['latin'],\n  variable: '--font-montserrat',\n  weight: ['300', '400', '500', '600', '700']\n});\nexport const metadata: Metadata = {\n  title: 'Colour My Space - Interior Design & E-commerce',\n  description: 'Premium interior design services and curated product collection'\n};\nexport default function RootLayout({\n  children\n}: {\n  children: React.ReactNode;\n}) {\n  // Note: Replace with your actual Google Client ID\n  const googleClientId = process.env.NEXT_PUBLIC_GOOGLE_CLIENT_ID || '';\n  return <html lang=\"en\">\n      <body className={`${inter.className} ${playfair.variable} ${montserrat.variable}`}>\n        <NextAuthProvider>\n          <AppProvider>{children}</AppProvider>\n        </NextAuthProvider>\n      </body>\n    </html>;\n}"],"names":["React","createContext","useContext","useReducer","useEffect","useRef","apiClient","User","Product","CartItem","Order","LoadingState","ErrorState","State","getCurrentUser","onAuthStateChange","getUserProfile","Action","type","payload","initialState","user","token","products","cartItems","orders","appointments","loading","cart","auth","error","ACTIONS","SET_USER","SET_TOKEN","SET_PRODUCTS","SET_CART_ITEMS","SET_ORDERS","SET_APPOINTMENTS","SET_LOADING","SET_ERROR","ADD_TO_CART","REMOVE_FROM_CART","UPDATE_CART_ITEM","CLEAR_CART","ADD_ORDER","appReducer","state","action","value","existingItem","find","item","product_id","updatedCartItems","map","quantity","filter","AppContext","setUser","setToken","setLoading","setError","fetchProducts","Promise","fetchCartItems","addToCart","product","updateCartItem","productId","removeFromCart","clearCart","fetchOrders","createOrder","orderData","login","credentials","register","userData","logout","verifyToken","fetchUserProfile","updateUserProfile","profileData","createProduct","productData","updateProduct","id","fetchProductBySlug","slug","searchProducts","params","q","search","category","minPrice","maxPrice","page","limit","fetchAppointments","filters","status","date","createAppointment","appointmentData","appointment_date","notes","updateAppointment","updateData","addToCartWithAuth","success","requiresLogin","clearPendingCartAction","undefined","AppProviderProps","children","ReactNode","AppProvider","FC","dispatch","tempSavedCart","console","log","isMounted","initializeAuth","supabaseUser","userProfile","userObject","name","user_metadata","full_name","email","split","avatar","picture","role","created_at","localStorage","setItem","JSON","stringify","removeItem","unsubscribe","event","session","then","module","useCartStore","getState","response","getCartItems","data","forEach","addItem","warn","message","items","length","getProducts","productsData","Array","isArray","mapImageIdentifierToClass","identifier","lowerIdentifier","toLowerCase","includes","formattedProducts","price","parseFloat","image_url","startsWith","imageClass","Error","ongoingCartRequests","Set","has","add","delete","cartItem","Date","now","updateItem","currentCart","parse","getItem","existingItemIndex","findIndex","splice","p","push","user_id","updatedCart","getOrders","fetch","headers","result","json","method","body","current","createClient","supabase","signOut","supabaseSignOutError","authSignOutError","apiClientError","resolve","setTimeout","updatedProducts","getProductBySlug","existingIndex","pagination","getAppointments","useAppContext","context","SessionContextProvider","NextAuthProvider"],"mappings":"0BAAA,EAAA,CAAA,CAAA,CACA,UAAA,0CACA,cCFA,EAAA,CAAA,CAAA,CACA,UAAA,sDACA,SAAA,oDACA,cCHA,EAAA,CAAA,CAAA,CACA,UAAA,gDACA,SAAA,8CACA,2BCFA,IAAA,EAAA,EAAA,CAAA,CAAA,OACO,IAAM,EAAa,CAAA,EAAA,EAAA,uBAAA,AAAuB,EAC7C,WAAa,MAAM,AAAI,MAAM,kOAAoO,EACjQ,2DACA,cAES,EAAc,CAAA,EAAA,EAAA,uBAAA,AAAuB,EAC9C,WAAa,MAAM,AAAI,MAAM,oOAAsO,EACnQ,2DACA,eAES,EAAgB,CAAA,EAAA,EAAA,uBAAA,AAAuB,EAChD,WAAa,MAAM,AAAI,MAAM,wOAA0O,EACvQ,2DACA,uGAdJ,IAAA,EAAA,EAAA,CAAA,CAAA,OACO,IAAM,EAAa,CAAA,EAAA,EAAA,uBAAA,AAAuB,EAC7C,WAAa,MAAM,AAAI,MAAM,kOAAoO,EACjQ,uCACA,cAES,EAAc,CAAA,EAAA,EAAA,uBAAA,AAAuB,EAC9C,WAAa,MAAM,AAAI,MAAM,oOAAsO,EACnQ,uCACA,eAES,EAAgB,CAAA,EAAA,EAAA,uBAAA,AAAuB,EAChD,WAAa,MAAM,AAAI,MAAM,wOAA0O,EACvQ,uCACA,kKEbG,IAAM,EAAmB,CAAA,EAAA,AADhC,EAAA,CAAA,CAAA,OACgC,uBAAA,AAAuB,EACnD,WAAa,MAAM,AAAI,MAAM,8OAAgP,EAC7Q,oEACA,0EAHG,IAAM,EAAmB,CAAA,EADhC,AACgC,EADhC,CAAA,CAAA,OACgC,uBAAA,AAAuB,EACnD,WAAa,MAAM,AAAI,MAAM,8OAAgP,EAC7Q,gDACA,qJILJ,EAAA,EAAA,CAAA,CAAA,OACA,IAAM,EAAW,CACb,UAAW,EAAA,OAAS,CAAC,SAAS,CAC9B,MAAO,CACH,WAAY,4BACZ,UAAW,QAEf,CACJ,CAEI,AAAsB,MAAM,GAA5B,OAAS,CAAC,QAAQ,GAClB,EAAS,QAAQ,CAAG,EAAA,OAAS,CAAC,QAAA,AAAQ,EFX1C,IAAA,EAAA,EAAA,CAAA,CAAA,OACA,IAAM,EAAW,CACb,UAAW,EAAA,OAAS,CAAC,SAAS,CAC9B,MAAO,CACH,WAAY,kDACZ,UAAW,QAEf,CACJ,CAE0B,MAAM,CAA5B,EAAA,OAAS,CAAC,QAAQ,GAClB,EAAS,QAAQ,CAAG,EAAA,OAAS,CAAC,QAAA,AAAQ,ECX1C,IAAA,EAAA,EAAA,CAAA,CAAA,OACA,IAAM,EAAW,CACb,UAAW,EAAA,OAAS,CAAC,SAAS,CAC9B,MAAO,CACH,WAAY,sCACZ,UAAW,QAEf,CACJ,CAEI,AAAsB,MAAM,GAA5B,OAAS,CAAC,QAAQ,GAClB,EAAS,QAAQ,CAAG,EAAA,OAAS,CAAC,QAAA,AAAQ,EER1C,IAAA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OAsBe,SAAS,EAAW,UACjC,CAAQ,CAGT,EAGC,MAAO,CAAA,EAAA,EAAA,GAAA,EAAC,OAAA,CAAK,KAAK,cACd,CAAA,EAAA,EAAA,GAAA,EAAC,OAAA,CAAK,UAAW,CAAA,EDpBR,ACoBW,EAAM,SAAS,CAAC,CAAC,EHpB5B,AGoB8B,EAAS,QAAQ,CAAC,CAAC,EFpBjD,AEoBmD,EAAW,QAAQ,CAAA,CAAE,UAC/E,CAAA,EAAA,EAAA,GAAA,EAAC,EAAA,gBAAgB,CAAA,UACf,CAAA,EAAA,EAAA,GAAA,EAAC,EAAA,WAAW,CAAA,UAAE,SAIxB,mCAlBkC,CAChC,MAAO,iDACP,YAAa,iEACf","ignoreList":[0,1,2,3,5,7,8,9]}
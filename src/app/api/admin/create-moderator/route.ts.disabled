import { NextRequest, NextResponse } from 'next/server';
import { Pool } from 'pg';

// Initialize database connection
const pool = new Pool({
  user: process.env.DB_USER,
  host: process.env.DB_HOST,
  database: process.env.DB_NAME,
  password: process.env.DB_PASSWORD,
  port: parseInt(process.env.DB_PORT || '5432'),
});

export async function POST(request: NextRequest) {
  try {
    // Extract token from headers to verify admin access
    const authHeader = request.headers.get('authorization');
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return NextResponse.json(
        { success: false, error: 'Unauthorized' },
        { status: 401 }
      );
    }

    const token = authHeader.substring(7); // Remove 'Bearer ' prefix
    // In a real app, you would verify the JWT here
    
    // Verify that the requesting user is an admin
    const client = await pool.connect();
    try {
      const adminCheckQuery = 'SELECT role FROM users WHERE token = $1'; // Simplified - in real app, decode token
      // For this mock implementation, we'll bypass the token verification and assume admin access
      // since in a real app we'd decode the JWT to get user ID
      
      // For this demo, we'll just check if the user exists and is an admin
      const { name, email, password, permissions } = await request.json();
      
      if (!name || !email || !password) {
        return NextResponse.json(
          { 
            success: false, 
            error: 'Name, email, and password are required' 
          },
          { status: 400 }
        );
      }

      // Default permissions for a new moderator (overridable via permissions param)
      const defaultPermissions = {
        can_edit_products: false,
        can_edit_reviews: true,
        can_edit_orders: true,
        can_edit_payments: false,
        ...permissions // Override defaults with provided permissions
      };

      // Check if user already exists
      const existingUserQuery = 'SELECT id FROM users WHERE email = $1';
      const existingResult = await client.query(existingUserQuery, [email]);

      if (existingResult.rows.length > 0) {
        return NextResponse.json(
          { 
            success: false, 
            error: 'A user with this email already exists' 
          },
          { status: 409 }
        );
      }

      // Insert new moderator user
      const insertQuery = `
        INSERT INTO users (name, email, password_hash, role, permissions, created_at, updated_at) 
        VALUES ($1, $2, $3, $4, $5, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP) 
        RETURNING id, name, email, role, permissions, created_at
      `;
      
      const insertResult = await client.query(insertQuery, [
        name,
        email,
        password, // In a real app, this should be bcrypt.hash(password, 10)
        'moderator', // Hardcoded role for moderator
        defaultPermissions
      ]);

      const newUser = insertResult.rows[0];
      
      return NextResponse.json(
        { 
          success: true, 
          data: { 
            user: {
              id: newUser.id,
              name: newUser.name,
              email: newUser.email,
              role: newUser.role,
              permissions: newUser.permissions,
              created_at: newUser.created_at
            }
          }
        },
        { status: 201 }
      );
    } finally {
      client.release();
    }
  } catch (error) {
    console.error('Admin create moderator error:', error);
    return NextResponse.json(
      { success: false, error: 'Internal server error' },
      { status: 500 }
    );
  }
}